{"ast":null,"code":"// 默认配置\nconst DEFAULT_CONFIG = {\n  // 上报服务器域名配置\n  track_url: \"http://localhost:3300/\",\n  // debug启动配置\n  debug: false,\n  // 本地存储配置\n  local_storage: {\n    // 存储方式  localStorage || cookie\n    type: \"localStorage\",\n    // 存储名称\n    name: \"\",\n    // 关闭存储功能\n    disable: false,\n    // cookie存储时，采用安全的存储方式，即：\n    //当secure属性设置为true时，cookie只有在https协议下才能上传到服务器，而在http协议下是没法上传的，所以也不会被窃听\n    secure_cookie: false,\n    // cookie存储时，跨主域名存储配置\n    cross_subdomain_cookie: false,\n    // cookie方法存储时，配置保存过期时间\n    cookie_expiration: 1000\n  },\n  // 初始化sdk时触发的方法\n  loaded: function () {},\n  // 上报数据实现形式  post, get, img\n  track_type: \"img\",\n  // 单页面应用配置\n  SPA: {\n    // 开启SPA配置\n    is: false,\n    // SPA 实现类型，hash || history\n    mode: \"hash\"\n  },\n  // PV指标自动触发配置\n  pageview: true,\n  // 上报数据前，每个字段长度截取配置，默认不截取\n  truncateLength: -1,\n  // 会话超时时长，默认30分钟\n  session_interval_mins: 30,\n  isBpoint: true,\n  // 是否开启断点发送，默认开启\n  // 远程拉取可视化圈选插件地址\n  auto_visualization_src: \"http://localhost:3300/build/plugins/auto_visualization/main.js\",\n  stackSize: 10,\n  //信息存储栈大小 栈满 则打包 转存到待发送队列\n  stackTime: 3,\n  //信息存储栈时间（单位 秒） 定时扫描，栈有数据就发\n  queueSize: 20,\n  //待发送队列大小\n  queueTime: 5 //待发送队列 自动扫描发送时间\n\n}; // 配置\n\nconst CONFIG = {\n  DEBUG: false,\n  LIB_VERSION: \"0.1.0\",\n  isBpoint: true,\n  // 是否开启断点发送，默认开启\n  stackSize: 10,\n  //信息存储栈大小 栈满 则打包 转存到待发送队列\n  stackTime: 3,\n  //信息存储栈时间（单位 秒） 定时扫描，栈有数据就发\n  queueSize: 20,\n  //待发送队列大小\n  queueTime: 5 //待发送队列 自动扫描发送时间\n\n}; // 系统事件类型（事件分为：系统事件和业务事件）\n\nconst SYSTEM_EVENT_TYPE = \"se\"; // 业务事件类型\n\nconst BUSSINESS_EVENT_TYPE = \"be\"; // 系统事件列表\n\nconst SYSTEM_EVENT_OBJECT = {\n  // 会话开始事件\n  sxfData_session_start: {\n    data_type: SYSTEM_EVENT_TYPE\n  },\n  // 会话结束事件\n  sxfData_session_close: {\n    data_type: SYSTEM_EVENT_TYPE\n  },\n  // PV事件\n  sxfData_pv: {\n    data_type: SYSTEM_EVENT_TYPE\n  },\n  // 广告点击事件\n  sxfData_ad_click: {\n    data_type: SYSTEM_EVENT_TYPE\n  },\n  // 用户首次访问网站事件\n  sxfData_activate: {\n    data_type: SYSTEM_EVENT_TYPE\n  },\n  // A/B 测试事件\n  sxfData_abtest: {\n    data_type: SYSTEM_EVENT_TYPE\n  },\n  // 异常错误事件\n  sxfData_error: {\n    data_type: SYSTEM_EVENT_TYPE\n  },\n  // 用户注册事件\n  sxfData_u_signup: {\n    data_type: SYSTEM_EVENT_TYPE\n  },\n  // 用户登录事件\n  sxfData_u_login: {\n    data_type: SYSTEM_EVENT_TYPE\n  },\n  // 用户登出事件\n  sxfData_u_logout: {\n    data_type: SYSTEM_EVENT_TYPE\n  },\n  // 用户属性设置事件\n  sxfData_u_property: {\n    data_type: SYSTEM_EVENT_TYPE\n  }\n}; // People类系统保留属性，用户设置这些属性将无法成功\n\nconst PEOPLE_RESERVED_PROPERTY = [\"$deviceUdid\", \"$toekn\"]; // People类属性事件id，全局唯一\n\nconst PEOPLE_PROPERTY_ID = \"sxfData_user_property\"; // Save the previous value of the device variable.\n\nvar previousDevice = window.device;\nvar device = {};\nvar changeOrientationList = []; // Add device as a global object.\n\nwindow.device = device; // The <html> element.\n\nvar documentElement = window.document.documentElement; // The client user agent string.\n// Lowercase, so we can use the more efficient indexOf(), instead of Regex\n\nvar userAgent = window.navigator.userAgent.toLowerCase(); // Detectable television devices.\n\nvar television = ['googletv', 'viera', 'smarttv', 'internet.tv', 'netcast', 'nettv', 'appletv', 'boxee', 'kylo', 'roku', 'dlnadoc', 'roku', 'pov_tv', 'hbbtv', 'ce-html']; // Main functions\n// --------------\n\ndevice.macos = function () {\n  return find('mac');\n};\n\ndevice.ios = function () {\n  return device.iphone() || device.ipod() || device.ipad();\n};\n\ndevice.iphone = function () {\n  return !device.windows() && find('iphone');\n};\n\ndevice.ipod = function () {\n  return find('ipod');\n};\n\ndevice.ipad = function () {\n  return find('ipad');\n};\n\ndevice.android = function () {\n  return !device.windows() && find('android');\n};\n\ndevice.androidPhone = function () {\n  return device.android() && find('mobile');\n};\n\ndevice.androidTablet = function () {\n  return device.android() && !find('mobile');\n};\n\ndevice.blackberry = function () {\n  return find('blackberry') || find('bb10') || find('rim');\n};\n\ndevice.blackberryPhone = function () {\n  return device.blackberry() && !find('tablet');\n};\n\ndevice.blackberryTablet = function () {\n  return device.blackberry() && find('tablet');\n};\n\ndevice.windows = function () {\n  return find('windows');\n};\n\ndevice.windowsPhone = function () {\n  return device.windows() && find('phone');\n};\n\ndevice.windowsTablet = function () {\n  return device.windows() && find('touch') && !device.windowsPhone();\n};\n\ndevice.fxos = function () {\n  return (find('(mobile') || find('(tablet')) && find(' rv:');\n};\n\ndevice.fxosPhone = function () {\n  return device.fxos() && find('mobile');\n};\n\ndevice.fxosTablet = function () {\n  return device.fxos() && find('tablet');\n};\n\ndevice.meego = function () {\n  return find('meego');\n};\n\ndevice.cordova = function () {\n  return window.cordova && location.protocol === 'file:';\n};\n\ndevice.nodeWebkit = function () {\n  return typeof window.process === 'object';\n};\n\ndevice.mobile = function () {\n  return device.androidPhone() || device.iphone() || device.ipod() || device.windowsPhone() || device.blackberryPhone() || device.fxosPhone() || device.meego();\n};\n\ndevice.tablet = function () {\n  return device.ipad() || device.androidTablet() || device.blackberryTablet() || device.windowsTablet() || device.fxosTablet();\n};\n\ndevice.desktop = function () {\n  return !device.tablet() && !device.mobile();\n};\n\ndevice.television = function () {\n  var i = 0;\n\n  while (i < television.length) {\n    if (find(television[i])) {\n      return true;\n    }\n\n    i++;\n  }\n\n  return false;\n};\n\ndevice.portrait = function () {\n  if (screen.orientation && Object.prototype.hasOwnProperty.call(window, 'onorientationchange')) {\n    return screen.orientation.type.includes('portrait');\n  }\n\n  return window.innerHeight / window.innerWidth > 1;\n};\n\ndevice.landscape = function () {\n  if (screen.orientation && Object.prototype.hasOwnProperty.call(window, 'onorientationchange')) {\n    return screen.orientation.type.includes('landscape');\n  }\n\n  return window.innerHeight / window.innerWidth < 1;\n}; // Public Utility Functions\n// ------------------------\n// Run device.js in noConflict mode,\n// returning the device variable to its previous owner.\n\n\ndevice.noConflict = function () {\n  window.device = previousDevice;\n  return this;\n}; // Private Utility Functions\n// -------------------------\n// Simple UA string search\n\n\nfunction find(needle) {\n  return userAgent.indexOf(needle) !== -1;\n} // Check if documentElement already has a given class.\n\n\nfunction hasClass(className) {\n  return documentElement.className.match(new RegExp(className, 'i'));\n} // Add one or more CSS classes to the <html> element.\n\n\nfunction addClass(className) {\n  var currentClassNames = null;\n\n  if (!hasClass(className)) {\n    currentClassNames = documentElement.className.replace(/^\\s+|\\s+$/g, '');\n    documentElement.className = currentClassNames + ' ' + className;\n  }\n} // Remove single CSS class from the <html> element.\n\n\nfunction removeClass(className) {\n  if (hasClass(className)) {\n    documentElement.className = documentElement.className.replace(' ' + className, '');\n  }\n} // HTML Element Handling\n// ---------------------\n// Insert the appropriate CSS class based on the _user_agent.\n\n\nif (device.ios()) {\n  if (device.ipad()) {\n    addClass('ios ipad tablet');\n  } else if (device.iphone()) {\n    addClass('ios iphone mobile');\n  } else if (device.ipod()) {\n    addClass('ios ipod mobile');\n  }\n} else if (device.macos()) {\n  addClass('macos desktop');\n} else if (device.android()) {\n  if (device.androidTablet()) {\n    addClass('android tablet');\n  } else {\n    addClass('android mobile');\n  }\n} else if (device.blackberry()) {\n  if (device.blackberryTablet()) {\n    addClass('blackberry tablet');\n  } else {\n    addClass('blackberry mobile');\n  }\n} else if (device.windows()) {\n  if (device.windowsTablet()) {\n    addClass('windows tablet');\n  } else if (device.windowsPhone()) {\n    addClass('windows mobile');\n  } else {\n    addClass('windows desktop');\n  }\n} else if (device.fxos()) {\n  if (device.fxosTablet()) {\n    addClass('fxos tablet');\n  } else {\n    addClass('fxos mobile');\n  }\n} else if (device.meego()) {\n  addClass('meego mobile');\n} else if (device.nodeWebkit()) {\n  addClass('node-webkit');\n} else if (device.television()) {\n  addClass('television');\n} else if (device.desktop()) {\n  addClass('desktop');\n}\n\nif (device.cordova()) {\n  addClass('cordova');\n} // Orientation Handling\n// --------------------\n// Handle device orientation changes.\n\n\nfunction handleOrientation() {\n  if (device.landscape()) {\n    removeClass('portrait');\n    addClass('landscape');\n    walkOnChangeOrientationList('landscape');\n  } else {\n    removeClass('landscape');\n    addClass('portrait');\n    walkOnChangeOrientationList('portrait');\n  }\n\n  setOrientationCache();\n}\n\nfunction walkOnChangeOrientationList(newOrientation) {\n  for (var index in changeOrientationList) {\n    changeOrientationList[index](newOrientation);\n  }\n}\n\ndevice.onChangeOrientation = function (cb) {\n  if (typeof cb == 'function') {\n    changeOrientationList.push(cb);\n  }\n}; // Detect whether device supports orientationchange event,\n// otherwise fall back to the resize event.\n\n\nvar orientationEvent = 'resize';\n\nif (Object.prototype.hasOwnProperty.call(window, 'onorientationchange')) {\n  orientationEvent = 'orientationchange';\n} // Listen for changes in orientation.\n\n\nif (window.addEventListener) {\n  window.addEventListener(orientationEvent, handleOrientation, false);\n} else if (window.attachEvent) {\n  window.attachEvent(orientationEvent, handleOrientation);\n} else {\n  window[orientationEvent] = handleOrientation;\n}\n\nhandleOrientation(); // Public functions to get the current value of type, os, or orientation\n// ---------------------------------------------------------------------\n\nfunction findMatch(arr) {\n  for (var i = 0; i < arr.length; i++) {\n    if (device[arr[i]]()) {\n      return arr[i];\n    }\n  }\n\n  return 'unknown';\n}\n\ndevice.type = findMatch(['mobile', 'tablet', 'desktop']);\ndevice.os = findMatch(['ios', 'iphone', 'ipad', 'ipod', 'android', 'blackberry', 'windows', 'fxos', 'meego', 'television']);\n\nfunction setOrientationCache() {\n  device.orientation = findMatch(['portrait', 'landscape']);\n}\n\nsetOrientationCache();\n\nconst utf8Encode = function (string) {\n  string = (string + '').replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n  var utftext = '',\n      start,\n      end;\n  var stringl = 0,\n      n;\n  start = end = 0;\n  stringl = string.length;\n\n  for (n = 0; n < stringl; n++) {\n    var c1 = string.charCodeAt(n);\n    var enc = null;\n\n    if (c1 < 128) {\n      end++;\n    } else if (c1 > 127 && c1 < 2048) {\n      enc = String.fromCharCode(c1 >> 6 | 192, c1 & 63 | 128);\n    } else {\n      enc = String.fromCharCode(c1 >> 12 | 224, c1 >> 6 & 63 | 128, c1 & 63 | 128);\n    }\n\n    if (enc !== null) {\n      if (end > start) {\n        utftext += string.substring(start, end);\n      }\n\n      utftext += enc;\n      start = end = n + 1;\n    }\n  }\n\n  if (end > start) {\n    utftext += string.substring(start, string.length);\n  }\n\n  return utftext;\n};\n\nconst base64Encode = function (data) {\n  var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n  var o1,\n      o2,\n      o3,\n      h1,\n      h2,\n      h3,\n      h4,\n      bits,\n      i = 0,\n      ac = 0,\n      enc = '',\n      tmp_arr = [];\n\n  if (!data) {\n    return data;\n  }\n\n  data = utf8Encode(data);\n\n  do {\n    // pack three octets into four hexets\n    o1 = data.charCodeAt(i++);\n    o2 = data.charCodeAt(i++);\n    o3 = data.charCodeAt(i++);\n    bits = o1 << 16 | o2 << 8 | o3;\n    h1 = bits >> 18 & 0x3f;\n    h2 = bits >> 12 & 0x3f;\n    h3 = bits >> 6 & 0x3f;\n    h4 = bits & 0x3f; // use hexets to index into b64, and append result to encoded string\n\n    tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);\n  } while (i < data.length);\n\n  enc = tmp_arr.join('');\n\n  switch (data.length % 3) {\n    case 1:\n      enc = enc.slice(0, -2) + '==';\n      break;\n\n    case 2:\n      enc = enc.slice(0, -1) + '=';\n      break;\n  }\n\n  return enc;\n}; // 兼容单元测试环境\n\n\nlet win$1;\n\nif (typeof window === \"undefined\") {\n  win$1 = {\n    navigator: {\n      userAgent: \"\"\n    },\n    location: {\n      pathname: \"\",\n      href: \"\"\n    },\n    document: {\n      URL: \"\"\n    },\n    screen: {\n      width: \"\",\n      height: \"\"\n    }\n  };\n} else {\n  win$1 = window;\n}\n\nfunction toString(object) {\n  return Object.prototype.toString.call(object);\n}\n\nfunction isObject(object) {\n  return toString(object) === \"[object Object]\";\n}\n\nfunction isFunction(object) {\n  return toString(object) === \"[object Function]\";\n}\n\nfunction each(object, factory) {\n  for (var i = 0, l = object.length; i < l; i++) {\n    if (factory.call(object, object[i], i) === false) {\n      break;\n    }\n  }\n}\n\nvar NA_VERSION = \"-1\";\nvar external = win$1.external;\nvar userAgent$1 = win$1.navigator.userAgent || \"\";\nvar appVersion = win$1.navigator.appVersion || \"\";\nvar vendor = win$1.navigator.vendor || \"\";\nvar detector = {};\nvar re_msie = /\\b(?:msie |ie |trident\\/[0-9].*rv[ :])([0-9.]+)/;\nvar re_blackberry_10 = /\\bbb10\\b.+?\\bversion\\/([\\d.]+)/;\nvar re_blackberry_6_7 = /\\bblackberry\\b.+\\bversion\\/([\\d.]+)/;\nvar re_blackberry_4_5 = /\\bblackberry\\d+\\/([\\d.]+)/; // http://zakwu.me/2015/12/15/an-zhuo-shou-ji-uashou-ji/ 参考\n// 硬件设备信息识别表达式。\n// 使用数组可以按优先级排序。\n\nvar DEVICES = [[\"nokia\", function (ua) {\n  // 不能将两个表达式合并，因为可能出现 \"nokia; nokia 960\"\n  // 这种情况下会优先识别出 nokia/-1\n  if (ua.indexOf(\"nokia \") !== -1) {\n    return /\\bnokia ([0-9]+)?/;\n  } else {\n    return /\\bnokia([a-z0-9]+)?/;\n  }\n}], // 三星有 Android 和 WP 设备。\n[\"samsung\", function (ua) {\n  if (ua.indexOf(\"samsung\") !== -1) {\n    return /\\bsamsung(?:[ \\-](?:sgh|gt|sm))?-([a-z0-9]+)/;\n  } else {\n    return /\\b(?:sgh|sch|gt|sm)-([a-z0-9]+)/;\n  }\n}], [\"wp\", function (ua) {\n  return ua.indexOf(\"windows phone \") !== -1 || ua.indexOf(\"xblwp\") !== -1 || ua.indexOf(\"zunewp\") !== -1 || ua.indexOf(\"windows ce\") !== -1;\n}], [\"pc\", \"windows\"], [\"ipad\", \"ipad\"], // ipod 规则应置于 iphone 之前。\n[\"ipod\", \"ipod\"], [\"iphone\", /\\biphone\\b|\\biph(\\d)/], [\"mac\", \"macintosh\"], // 小米\n[\"mi\", /\\bmi[ \\-]?([a-z0-9 ]+(?= build|\\)))/], // 红米\n[\"hongmi\", /\\bhm\\b|redmi[ \\-]?([a-z0-9]+)/], [\"aliyun\", /\\baliyunos\\b(?:[\\-](\\d+))?/], [\"meizu\", function (ua) {\n  return ua.indexOf(\"meizu\") >= 0 ? /\\bmeizu[\\/ ]([a-z0-9]+)\\b/ : /\\bm([0-9cx]{1,4})\\b/;\n}], [\"nexus\", /\\bnexus ([0-9s.]+)/], [\"huawei\", function (ua) {\n  var re_mediapad = /\\bmediapad (.+?)(?= build\\/huaweimediapad\\b)/;\n\n  if (ua.indexOf(\"huawei-huawei\") !== -1) {\n    return /\\bhuawei\\-huawei\\-([a-z0-9\\-]+)/;\n  } else if (re_mediapad.test(ua)) {\n    return re_mediapad;\n  } else {\n    return /\\bhuawei[ _\\-]?([a-z0-9]+)/;\n  }\n}], [\"lenovo\", function (ua) {\n  if (ua.indexOf(\"lenovo-lenovo\") !== -1) {\n    return /\\blenovo\\-lenovo[ \\-]([a-z0-9]+)/;\n  } else {\n    return /\\blenovo[ \\-]?([a-z0-9]+)/;\n  }\n}], // 中兴\n[\"zte\", function (ua) {\n  if (/\\bzte\\-[tu]/.test(ua)) {\n    return /\\bzte-[tu][ _\\-]?([a-su-z0-9\\+]+)/;\n  } else {\n    return /\\bzte[ _\\-]?([a-su-z0-9\\+]+)/;\n  }\n}], // 步步高\n[\"vivo\", /\\bvivo(?: ([a-z0-9]+))?/], [\"htc\", function (ua) {\n  if (/\\bhtc[a-z0-9 _\\-]+(?= build\\b)/.test(ua)) {\n    return /\\bhtc[ _\\-]?([a-z0-9 ]+(?= build))/;\n  } else {\n    return /\\bhtc[ _\\-]?([a-z0-9 ]+)/;\n  }\n}], [\"oppo\", /\\boppo[_]([a-z0-9]+)/], [\"konka\", /\\bkonka[_\\-]([a-z0-9]+)/], [\"sonyericsson\", /\\bmt([a-z0-9]+)/], [\"coolpad\", /\\bcoolpad[_ ]?([a-z0-9]+)/], [\"lg\", /\\blg[\\-]([a-z0-9]+)/], [\"android\", /\\bandroid\\b|\\badr\\b/], [\"blackberry\", function (ua) {\n  if (ua.indexOf(\"blackberry\") >= 0) {\n    return /\\bblackberry\\s?(\\d+)/;\n  }\n\n  return \"bb10\";\n}]]; // 操作系统信息识别表达式\n\nvar OS = [[\"wp\", function (ua) {\n  if (ua.indexOf(\"windows phone \") !== -1) {\n    return /\\bwindows phone (?:os )?([0-9.]+)/;\n  } else if (ua.indexOf(\"xblwp\") !== -1) {\n    return /\\bxblwp([0-9.]+)/;\n  } else if (ua.indexOf(\"zunewp\") !== -1) {\n    return /\\bzunewp([0-9.]+)/;\n  }\n\n  return \"windows phone\";\n}], [\"windows\", /\\bwindows nt ([0-9.]+)/], [\"macosx\", /\\bmac os x ([0-9._]+)/], [\"iOS\", function (ua) {\n  if (/\\bcpu(?: iphone)? os /.test(ua)) {\n    return /\\bcpu(?: iphone)? os ([0-9._]+)/;\n  } else if (ua.indexOf(\"iph os \") !== -1) {\n    return /\\biph os ([0-9_]+)/;\n  } else {\n    return /\\bios\\b/;\n  }\n}], [\"yunos\", /\\baliyunos ([0-9.]+)/], [\"Android\", function (ua) {\n  if (ua.indexOf(\"android\") >= 0) {\n    return /\\bandroid[ \\/-]?([0-9.x]+)?/;\n  } else if (ua.indexOf(\"adr\") >= 0) {\n    if (ua.indexOf(\"mqqbrowser\") >= 0) {\n      return /\\badr[ ]\\(linux; u; ([0-9.]+)?/;\n    } else {\n      return /\\badr(?:[ ]([0-9.]+))?/;\n    }\n  }\n\n  return \"android\"; //return /\\b(?:android|\\badr)(?:[\\/\\- ](?:\\(linux; u; )?)?([0-9.x]+)?/;\n}], [\"chromeos\", /\\bcros i686 ([0-9.]+)/], [\"linux\", \"linux\"], [\"windowsce\", /\\bwindows ce(?: ([0-9.]+))?/], [\"symbian\", /\\bsymbian(?:os)?\\/([0-9.]+)/], [\"blackberry\", function (ua) {\n  var m = ua.match(re_blackberry_10) || ua.match(re_blackberry_6_7) || ua.match(re_blackberry_4_5);\n  return m ? {\n    version: m[1]\n  } : \"blackberry\";\n}]]; //浏览器内核\n\nvar ENGINE = [[\"edgehtml\", /edge\\/([0-9.]+)/], [\"trident\", re_msie], [\"blink\", function () {\n  return \"chrome\" in win$1 && \"CSS\" in win$1 && /\\bapplewebkit[\\/]?([0-9.+]+)/;\n}], [\"webkit\", /\\bapplewebkit[\\/]?([0-9.+]+)/], [\"gecko\", function (ua) {\n  var match;\n\n  if (match = ua.match(/\\brv:([\\d\\w.]+).*\\bgecko\\/(\\d+)/)) {\n    return {\n      version: match[1] + \".\" + match[2]\n    };\n  }\n}], [\"presto\", /\\bpresto\\/([0-9.]+)/], [\"androidwebkit\", /\\bandroidwebkit\\/([0-9.]+)/], [\"coolpadwebkit\", /\\bcoolpadwebkit\\/([0-9.]+)/], [\"u2\", /\\bu2\\/([0-9.]+)/], [\"u3\", /\\bu3\\/([0-9.]+)/]];\nvar BROWSER = [// Microsoft Edge Browser, Default browser in Windows 10.\n[\"edge\", /edge\\/([0-9.]+)/], // Sogou.\n[\"sogou\", function (ua) {\n  if (ua.indexOf(\"sogoumobilebrowser\") >= 0) {\n    return /sogoumobilebrowser\\/([0-9.]+)/;\n  } else if (ua.indexOf(\"sogoumse\") >= 0) {\n    return true;\n  }\n\n  return / se ([0-9.x]+)/;\n}], // TheWorld (世界之窗)\n// 由于裙带关系，TheWorld API 与 360 高度重合。\n// 只能通过 UA 和程序安装路径中的应用程序名来区分。\n// TheWorld 的 UA 比 360 更靠谱，所有将 TheWorld 的规则放置到 360 之前。\n[\"theworld\", function () {\n  var x = checkTW360External(\"theworld\");\n\n  if (typeof x !== \"undefined\") {\n    return x;\n  }\n\n  return \"theworld\";\n}], // 360SE, 360EE.\n[\"360\", function (ua) {\n  var x = checkTW360External(\"360se\");\n\n  if (typeof x !== \"undefined\") {\n    return x;\n  }\n\n  if (ua.indexOf(\"360 aphone browser\") !== -1) {\n    return /\\b360 aphone browser \\(([^\\)]+)\\)/;\n  }\n\n  return /\\b360(?:se|ee|chrome|browser)\\b/;\n}], // Maxthon\n[\"maxthon\", function () {\n  try {\n    if (external && (external.mxVersion || external.max_version)) {\n      return {\n        version: external.mxVersion || external.max_version\n      };\n    }\n  } catch (ex) {\n    /* */\n  }\n\n  return /\\b(?:maxthon|mxbrowser)(?:[ \\/]([0-9.]+))?/;\n}], [\"micromessenger\", /\\bmicromessenger\\/([\\d.]+)/], [\"qq\", /\\bm?qqbrowser\\/([0-9.]+)/], [\"green\", \"greenbrowser\"], [\"tt\", /\\btencenttraveler ([0-9.]+)/], [\"liebao\", function (ua) {\n  if (ua.indexOf(\"liebaofast\") >= 0) {\n    return /\\bliebaofast\\/([0-9.]+)/;\n  }\n\n  if (ua.indexOf(\"lbbrowser\") === -1) {\n    return false;\n  }\n\n  var version;\n\n  try {\n    if (external && external.LiebaoGetVersion) {\n      version = external.LiebaoGetVersion();\n    }\n  } catch (ex) {\n    /* */\n  }\n\n  return {\n    version: version || NA_VERSION\n  };\n}], [\"tao\", /\\btaobrowser\\/([0-9.]+)/], [\"coolnovo\", /\\bcoolnovo\\/([0-9.]+)/], [\"saayaa\", \"saayaa\"], // 有基于 Chromniun 的急速模式和基于 IE 的兼容模式。必须在 IE 的规则之前。\n[\"baidu\", /\\b(?:ba?idubrowser|baiduhd)[ \\/]([0-9.x]+)/], // 后面会做修复版本号，这里只要能识别是 IE 即可。\n[\"ie\", re_msie], [\"mi\", /\\bmiuibrowser\\/([0-9.]+)/], // Opera 15 之后开始使用 Chromniun 内核，需要放在 Chrome 的规则之前。\n[\"opera\", function (ua) {\n  var re_opera_old = /\\bopera.+version\\/([0-9.ab]+)/;\n  var re_opera_new = /\\bopr\\/([0-9.]+)/;\n  return re_opera_old.test(ua) ? re_opera_old : re_opera_new;\n}], [\"oupeng\", /\\boupeng\\/([0-9.]+)/], [\"yandex\", /yabrowser\\/([0-9.]+)/], // 支付宝手机客户端\n[\"ali-ap\", function (ua) {\n  if (ua.indexOf(\"aliapp\") > 0) {\n    return /\\baliapp\\(ap\\/([0-9.]+)\\)/;\n  } else {\n    return /\\balipayclient\\/([0-9.]+)\\b/;\n  }\n}], // 支付宝平板客户端\n[\"ali-ap-pd\", /\\baliapp\\(ap-pd\\/([0-9.]+)\\)/], // 支付宝商户客户端\n[\"ali-am\", /\\baliapp\\(am\\/([0-9.]+)\\)/], // 淘宝手机客户端\n[\"ali-tb\", /\\baliapp\\(tb\\/([0-9.]+)\\)/], // 淘宝平板客户端\n[\"ali-tb-pd\", /\\baliapp\\(tb-pd\\/([0-9.]+)\\)/], // 天猫手机客户端\n[\"ali-tm\", /\\baliapp\\(tm\\/([0-9.]+)\\)/], // 天猫平板客户端\n[\"ali-tm-pd\", /\\baliapp\\(tm-pd\\/([0-9.]+)\\)/], // UC 浏览器，可能会被识别为 Android 浏览器，规则需要前置。\n// UC 桌面版浏览器携带 Chrome 信息，需要放在 Chrome 之前。\n[\"uc\", function (ua) {\n  if (ua.indexOf(\"ucbrowser/\") >= 0) {\n    return /\\bucbrowser\\/([0-9.]+)/;\n  } else if (ua.indexOf(\"ubrowser/\") >= 0) {\n    return /\\bubrowser\\/([0-9.]+)/;\n  } else if (/\\buc\\/[0-9]/.test(ua)) {\n    return /\\buc\\/([0-9.]+)/;\n  } else if (ua.indexOf(\"ucweb\") >= 0) {\n    // `ucweb/2.0` is compony info.\n    // `UCWEB8.7.2.214/145/800` is browser info.\n    return /\\bucweb([0-9.]+)?/;\n  } else {\n    return /\\b(?:ucbrowser|uc)\\b/;\n  }\n}], [\"chrome\", / (?:chrome|crios|crmo)\\/([0-9.]+)/], // Android 默认浏览器。该规则需要在 safari 之前。\n[\"android\", function (ua) {\n  if (ua.indexOf(\"android\") === -1) {\n    return;\n  }\n\n  return /\\bversion\\/([0-9.]+(?: beta)?)/;\n}], [\"blackberry\", function (ua) {\n  var m = ua.match(re_blackberry_10) || ua.match(re_blackberry_6_7) || ua.match(re_blackberry_4_5);\n  return m ? {\n    version: m[1]\n  } : \"blackberry\";\n}], [\"safari\", /\\bversion\\/([0-9.]+(?: beta)?)(?: mobile(?:\\/[a-z0-9]+)?)? safari\\//], // 如果不能被识别为 Safari，则猜测是 WebView。\n[\"webview\", /\\bcpu(?: iphone)? os (?:[0-9._]+).+\\bapplewebkit\\b/], [\"firefox\", /\\bfirefox\\/([0-9.ab]+)/], [\"nokia\", /\\bnokiabrowser\\/([0-9.]+)/]]; // 针对同源的 TheWorld 和 360 的 external 对象进行检测。\n// @param {String} key, 关键字，用于检测浏览器的安装路径中出现的关键字。\n// @return {Undefined,Boolean,Object} 返回 undefined 或 false 表示检测未命中。\n\nfunction checkTW360External(key) {\n  if (!external) {\n    return;\n  } // return undefined.\n\n\n  try {\n    //        360安装路径：\n    //        C:%5CPROGRA~1%5C360%5C360se3%5C360SE.exe\n    var runpath = external.twGetRunPath.toLowerCase(); // 360SE 3.x ~ 5.x support.\n    // 暴露的 external.twGetVersion 和 external.twGetSecurityID 均为 undefined。\n    // 因此只能用 try/catch 而无法使用特性判断。\n\n    var security = external.twGetSecurityID(win$1);\n    var version = external.twGetVersion(security);\n\n    if (runpath && runpath.indexOf(key) === -1) {\n      return false;\n    }\n\n    if (version) {\n      return {\n        version: version\n      };\n    }\n  } catch (ex) {\n    /* */\n  }\n} // 解析使用 Trident 内核的浏览器的 `浏览器模式` 和 `文档模式` 信息。\n// @param {String} ua, userAgent string.\n// @return {Object}\n\n\nfunction IEMode(ua) {\n  if (!re_msie.test(ua)) {\n    return null;\n  }\n\n  var m, engineMode, engineVersion, browserMode, browserVersion; // IE8 及其以上提供有 Trident 信息，\n  // 默认的兼容模式，UA 中 Trident 版本不发生变化。\n\n  if (ua.indexOf(\"trident/\") !== -1) {\n    m = /\\btrident\\/([0-9.]+)/.exec(ua);\n\n    if (m && m.length >= 2) {\n      // 真实引擎版本。\n      engineVersion = m[1];\n      var v_version = m[1].split(\".\");\n      v_version[0] = parseInt(v_version[0], 10) + 4;\n      browserVersion = v_version.join(\".\");\n    }\n  }\n\n  m = re_msie.exec(ua);\n  browserMode = m[1];\n  var v_mode = m[1].split(\".\");\n\n  if (typeof browserVersion === \"undefined\") {\n    browserVersion = browserMode;\n  }\n\n  v_mode[0] = parseInt(v_mode[0], 10) - 4;\n  engineMode = v_mode.join(\".\");\n\n  if (typeof engineVersion === \"undefined\") {\n    engineVersion = engineMode;\n  }\n\n  return {\n    browserVersion: browserVersion,\n    browserMode: browserMode,\n    engineVersion: engineVersion,\n    engineMode: engineMode,\n    compatible: engineVersion !== engineMode\n  };\n} // UserAgent Detector.\n// @param {String} ua, userAgent.\n// @param {Object} expression\n// @return {Object}\n//    返回 null 表示当前表达式未匹配成功。\n\n\nfunction detect(name, expression, ua) {\n  var expr = isFunction(expression) ? expression.call(null, ua) : expression;\n\n  if (!expr) {\n    return null;\n  }\n\n  var info = {\n    name: name,\n    version: NA_VERSION,\n    codename: \"\"\n  };\n  var t = toString(expr);\n\n  if (expr === true) {\n    return info;\n  } else if (t === \"[object String]\") {\n    if (ua.indexOf(expr) !== -1) {\n      return info;\n    }\n  } else if (isObject(expr)) {\n    // Object\n    if (expr.hasOwnProperty(\"version\")) {\n      info.version = expr.version;\n    }\n\n    return info;\n  } else if (expr.exec) {\n    // RegExp\n    var m = expr.exec(ua);\n\n    if (m) {\n      if (m.length >= 2 && m[1]) {\n        info.version = m[1].replace(/_/g, \".\");\n      } else {\n        info.version = NA_VERSION;\n      }\n\n      return info;\n    }\n  }\n}\n\nvar na = {\n  name: \"\",\n  version: \"\"\n}; // 初始化识别。\n\nfunction init(ua, patterns, factory, detector) {\n  var detected = na;\n  each(patterns, function (pattern) {\n    var d = detect(pattern[0], pattern[1], ua);\n\n    if (d) {\n      detected = d;\n      return false;\n    }\n  });\n  factory.call(detector, detected.name, detected.version);\n} // 解析 UserAgent 字符串\n// @param {String} ua, userAgent string.\n// @return {Object}\n\n\nvar parse = function (ua) {\n  ua = (ua || \"\").toLowerCase();\n  var d = {};\n  init(ua, DEVICES, function (name, version) {\n    var v = parseFloat(version);\n    d.device = {\n      name: name,\n      version: v,\n      fullVersion: version\n    };\n    d.device[name] = v;\n  }, d);\n  init(ua, OS, function (name, version) {\n    var v = parseFloat(version);\n    d.os = {\n      name: name,\n      version: v,\n      fullVersion: version\n    };\n    d.os[name] = v;\n  }, d);\n  var ieCore = IEMode(ua);\n  init(ua, ENGINE, function (name, version) {\n    var mode = version; // IE 内核的浏览器，修复版本号及兼容模式。\n\n    if (ieCore) {\n      version = ieCore.engineVersion || ieCore.engineMode;\n      mode = ieCore.engineMode;\n    }\n\n    var v = parseFloat(version);\n    d.engine = {\n      name: name,\n      version: v,\n      fullVersion: version,\n      mode: parseFloat(mode),\n      fullMode: mode,\n      compatible: ieCore ? ieCore.compatible : false\n    };\n    d.engine[name] = v;\n  }, d);\n  init(ua, BROWSER, function (name, version) {\n    var mode = version; // IE 内核的浏览器，修复浏览器版本及兼容模式。\n\n    if (ieCore) {\n      // 仅修改 IE 浏览器的版本，其他 IE 内核的版本不修改。\n      if (name === \"ie\") {\n        version = ieCore.browserVersion;\n      }\n\n      mode = ieCore.browserMode;\n    }\n\n    var v = parseFloat(version);\n    d.browser = {\n      name: name,\n      version: v,\n      fullVersion: version,\n      mode: parseFloat(mode),\n      fullMode: mode,\n      compatible: ieCore ? ieCore.compatible : false\n    };\n    d.browser[name] = v;\n  }, d);\n  return d;\n};\n\ndetector = parse(userAgent$1 + \" \" + appVersion + \" \" + vendor);\nvar detector$1 = detector;\nvar ArrayProto = Array.prototype;\nvar FuncProto = Function.prototype;\nvar slice = ArrayProto.slice;\nvar nativeBind = FuncProto.bind; // 兼容单元测试环境\n\nlet win;\n\nif (typeof window === \"undefined\") {\n  win = {\n    navigator: {\n      userAgent: \"\"\n    },\n    location: {\n      pathname: \"\",\n      href: \"\"\n    },\n    document: {\n      URL: \"\"\n    },\n    screen: {\n      width: \"\",\n      height: \"\"\n    }\n  };\n} else {\n  win = window;\n}\n\nconst breaker = {};\nconst _ = {\n  each(obj, iterator, context) {\n    if (obj === null || obj === undefined) {\n      return;\n    }\n\n    if (Array.prototype.forEach && obj.forEach === Array.prototype.forEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (let i = 0, l = obj.length; i < l; i++) {\n        if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) {\n          return;\n        }\n      }\n    } else {\n      for (let key in obj) {\n        if (obj.hasOwnProperty.call(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) {\n            return;\n          }\n        }\n      }\n    }\n  },\n\n  extend(obj) {\n    _.each(Array.prototype.slice.call(arguments, 1), function (source) {\n      for (let prop in source) {\n        if (source[prop] !== void 0) {\n          obj[prop] = source[prop];\n        }\n      }\n    });\n\n    return obj;\n  },\n\n  isObject(obj) {\n    return obj === Object(obj) && !_.isArray(obj);\n  },\n\n  isUndefined(obj) {\n    return obj === void 0;\n  },\n\n  isArguments(obj) {\n    return !!(obj && hasOwnProperty.call(obj, \"callee\"));\n  },\n\n  toArray(iterable) {\n    if (!iterable) {\n      return [];\n    }\n\n    if (iterable.toArray) {\n      return iterable.toArray();\n    }\n\n    if (_.isArray(iterable)) {\n      return Array.prototype.slice.call(iterable);\n    }\n\n    if (_.isArguments(iterable)) {\n      return Array.prototype.slice.call(iterable);\n    }\n\n    return _.values(iterable);\n  },\n\n  values(obj) {\n    var results = [];\n\n    if (obj === null) {\n      return results;\n    }\n\n    _.each(obj, function (value) {\n      results[results.length] = value;\n    });\n\n    return results;\n  },\n\n  // 转化成json\n  JSONDecode(string) {\n    try {\n      return JSON.parse(string);\n    } catch (error) {\n      return {};\n    }\n  },\n\n  // json转化为string\n  JSONEncode(json) {\n    try {\n      return JSON.stringify(json);\n    } catch (error) {\n      return \"\";\n    }\n  },\n\n  // 判断类型是否为function\n  isFunction(fn) {\n    let bool = false;\n\n    if (typeof fn === \"function\") {\n      bool = true;\n    }\n\n    return bool;\n  },\n\n  base64Encode(str) {\n    return base64Encode(str);\n  },\n\n  sha1(str) {\n    return \"\";\n  },\n\n  // 对象的字段值截取\n  truncate(obj, length) {\n    let ret;\n\n    if (typeof obj === \"string\") {\n      ret = obj.slice(0, length);\n    } else if (_.isArray(obj)) {\n      ret = [];\n\n      _.each(obj, function (val) {\n        ret.push(_.truncate(val, length));\n      });\n    } else if (_.isObject(obj)) {\n      ret = {};\n\n      _.each(obj, function (val, key) {\n        ret[key] = _.truncate(val, length);\n      });\n    } else {\n      ret = obj;\n    }\n\n    return ret;\n  },\n\n  isNumber(obj) {\n    return Object.prototype.toString.call(obj) == \"[object Number]\";\n  },\n\n  isString(str) {\n    return Object.prototype.toString.call(str) == \"[object String]\";\n  },\n\n  HTTPBuildQuery(formdata, arg_separator) {\n    let use_val,\n        use_key,\n        tmp_arr = [];\n\n    if (_.isUndefined(arg_separator)) {\n      arg_separator = \"&\";\n    }\n\n    _.each(formdata, function (val, key) {\n      use_val = encodeURIComponent(val && val.toString());\n      use_key = encodeURIComponent(key);\n      tmp_arr[tmp_arr.length] = use_key + \"=\" + use_val;\n    });\n\n    return tmp_arr.join(arg_separator);\n  },\n\n  // 删除左右两端的空格\n  trim(str) {\n    if (!str) return;\n    return str.replace(/(^\\s*)|(\\s*$)/g, \"\");\n  },\n\n  // 验证yyyy-MM-dd日期格式\n  checkTime(timeString) {\n    const reg = /^(\\d{4})-(\\d{2})-(\\d{2})$/;\n\n    if (timeString) {\n      if (!reg.test(timeString)) {\n        return false;\n      } else {\n        return true;\n      }\n    } else {\n      return false;\n    }\n  },\n\n  // 返回指定url的域名\n  // 若不传入url，返回当前网页的域名\n  getHost(url) {\n    let host = \"\";\n\n    if (!url) {\n      url = document.URL;\n    }\n\n    const regex = /.*\\:\\/\\/([^\\/]*).*/;\n    const match = url.match(regex);\n\n    if (match) {\n      host = match[1];\n    }\n\n    return host;\n  },\n\n  // 获取url上指定参数的值\n  getQueryParam(url, param) {\n    const target = param.replace(/[\\[]/, \"\\\\[\").replace(/[\\]]/, \"\\\\]\");\n    const regexS = \"[\\\\?&]\" + target + \"=([^&#]*)\";\n    const regex = new RegExp(regexS);\n    const results = regex.exec(url);\n\n    if (results === null || results && typeof results[1] !== \"string\" && results[1].length) {\n      return \"\";\n    } else {\n      return decodeURIComponent(results[1]).replace(/\\+/g, \" \");\n    }\n  },\n\n  // 删除对象中空字段\n  deleteEmptyProperty(obj) {\n    if (!this.isObject(obj)) {\n      return;\n    }\n\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        if (obj[key] === null || this.isUndefined(obj[key]) || obj[key] === \"\") {\n          delete obj[key];\n        }\n      }\n    }\n\n    return obj;\n  }\n\n};\n\n_.isArray = Array.isArray || function (obj) {\n  return Object.prototype.toString.apply(obj) === \"[object Array]\";\n};\n\n_.loadScript = function (para) {\n  para = _.extend({\n    success: function () {},\n    error: function () {},\n    appendCall: function (g) {\n      document.getElementsByTagName(\"head\")[0].appendChild(g);\n    }\n  }, para);\n  var g = null;\n\n  if (para.type === \"css\") {\n    g = document.createElement(\"link\");\n    g.rel = \"stylesheet\";\n    g.href = para.url;\n  }\n\n  if (para.type === \"js\") {\n    g = document.createElement(\"script\");\n    g.async = \"async\";\n    g.setAttribute(\"charset\", \"UTF-8\");\n    g.src = para.url;\n    g.type = \"text/javascript\";\n  }\n\n  g.onload = g.onreadystatechange = function () {\n    if (!this.readyState || this.readyState === \"loaded\" || this.readyState === \"complete\") {\n      para.success();\n      g.onload = g.onreadystatechange = null;\n    }\n  };\n\n  g.onerror = function () {\n    para.error();\n    g.onerror = null;\n  }; // if iframe\n\n\n  para.appendCall(g);\n};\n\n_.register_event = function () {\n  // http://dean.edwards.name/weblog/2005/10/add-event/\n  // https://gist.github.com/1930440\n\n  /**\r\n   * @param {Object} element\r\n   * @param {string} type\r\n   * @param {function(...[*])} handler\r\n   * @param {boolean=} oldSchool\r\n   * @param {boolean=} useCapture\r\n   */\n  var register_event = function (element, type, handler, oldSchool, useCapture) {\n    if (!element) {\n      console.error(\"No valid element provided to register_event\");\n      return;\n    }\n\n    if (element.addEventListener && !oldSchool) {\n      element.addEventListener(type, handler, !!useCapture);\n    } else {\n      var ontype = \"on\" + type;\n      var old_handler = element[ontype]; // can be undefined\n\n      element[ontype] = makeHandler(element, handler, old_handler);\n    }\n  };\n\n  function makeHandler(element, new_handler, old_handlers) {\n    var handler = function (event) {\n      event = event || fixEvent(window.event); //这基本上发生在firefox中的其他脚本中\n      //覆盖onload回调函数，不传递事件\n      // 对象指向以前定义的回调。所有的浏览器\n      //没有定义窗口。事件实现addEventListener\n      //因此，dom_loaded处理程序仍然会像往常一样被触发。\n\n      if (!event) {\n        return undefined;\n      }\n\n      var ret = true;\n      var old_result, new_result;\n\n      if (_.isFunction(old_handlers)) {\n        old_result = old_handlers(event);\n      }\n\n      new_result = new_handler.call(element, event);\n\n      if (false === old_result || false === new_result) {\n        ret = false;\n      }\n\n      return ret;\n    };\n\n    return handler;\n  }\n\n  function fixEvent(event) {\n    if (event) {\n      event.preventDefault = fixEvent.preventDefault;\n      event.stopPropagation = fixEvent.stopPropagation;\n    }\n\n    return event;\n  }\n\n  fixEvent.preventDefault = function () {\n    this.returnValue = false;\n  };\n\n  fixEvent.stopPropagation = function () {\n    this.cancelBubble = true;\n  };\n\n  return register_event;\n}();\n\n_.register_hash_event = function (callback) {\n  _.register_event(window, \"hashchange\", callback);\n};\n\n_.getHashParam = function (hash, param) {\n  var matches = hash.match(new RegExp(param + \"=([^&]*)\"));\n  return matches ? matches[1] : null;\n}; // 客户端基本属性\n\n\n_.info = {\n  domain(referrer) {\n    const split = referrer.split(\"/\");\n\n    if (split.length >= 3) {\n      return split[2];\n    }\n\n    return \"\";\n  },\n\n  // 设备型号\n  deviceModel() {\n    let deviceModel = \"\";\n\n    if (device.android()) {\n      const sss = win.navigator.userAgent.split(\";\");\n      const i = sss.indexOf(\"Build/\");\n\n      if (i > -1) {\n        deviceModel = sss[i].substring(0, sss[i].indexOf(\"Build/\"));\n      }\n    } else if (device.ios()) {\n      if (device.iphone()) {\n        deviceModel = \"iPhone\";\n      }\n    }\n\n    return deviceModel;\n  },\n\n  properties() {\n    const windowsOs = {\n      \"5.0\": \"Win2000\",\n      \"5.1\": \"WinXP\",\n      \"5.2\": \"Win2003\",\n      \"6.0\": \"WindowsVista\",\n      \"6.1\": \"Win7\",\n      \"6.2\": \"Win8\",\n      \"6.3\": \"Win8.1\",\n      \"10.0\": \"Win10\"\n    };\n    const devicePlatform = device.type;\n\n    const deviceModel = _.trim(this.deviceModel());\n\n    const isWindows = device.windows();\n    let deviceOsVersion = detector$1.os.name + \" \" + detector$1.os.fullVersion;\n\n    if (isWindows) {\n      if (windowsOs[detector$1.os.fullVersion]) {\n        deviceOsVersion = windowsOs[detector$1.os.fullVersion];\n      }\n    }\n\n    return {\n      // 设备型号\n      deviceModel: deviceModel,\n      // 操作系统\n      deviceOs: detector$1.os.name,\n      // 操作系统版本\n      deviceOsVersion: deviceOsVersion,\n      // 设备平台\n      devicePlatform: devicePlatform,\n      // 浏览器名称\n      browser: detector$1.browser.name,\n      // 浏览器版本\n      browserVersion: detector$1.browser.fullVersion,\n      // 页面标题\n      title: win.document.title || \"\",\n      // 页面路径\n      urlPath: win.location.pathname || \"\",\n      // 页面url\n      currentUrl: document.URL,\n      // 域名\n      currentDomain: this.domain(document.URL),\n      // referrer 数据来源\n      referrer: win.document.referrer,\n      // referrer 域名\n      referringDomain: this.domain(win.document.referrer),\n      // 本地语言\n      language: win.navigator.language || \"\",\n      // 客户端分辨率 width\n      screenWidth: win.screen.width,\n      // 客户端分辨率 height\n      screenHeight: win.screen.height\n    };\n  }\n\n}; // 消息订阅/推送\n\n_.innerEvent = {\n  /**\r\n   * 订阅\r\n   *  */\n  on: function (key, fn) {\n    if (!this._list) {\n      this._list = {};\n    }\n\n    if (!this._list[key]) {\n      this._list[key] = [];\n    }\n\n    this._list[key].push(fn);\n  },\n  off: function (key) {\n    if (!this._list) {\n      this._list = {};\n    }\n\n    if (!this._list[key]) {\n      return;\n    } else {\n      delete this._list[key];\n    }\n  },\n\n  /**\r\n   * 推送\r\n   */\n  trigger: function () {\n    var args = Array.prototype.slice.call(arguments);\n    var key = args[0];\n    var arrFn = this._list && this._list[key];\n\n    if (!arrFn || arrFn.length === 0) {\n      return;\n    }\n\n    for (var i = 0; i < arrFn.length; i++) {\n      if (typeof arrFn[i] == \"function\") {\n        arrFn[i].apply(this, args);\n      }\n    }\n  }\n}; // 发送数据\n\n_.sendRequest = function (url, type, data, callback) {\n  data[\"_\"] = new Date().getTime().toString();\n\n  if (type === \"img\") {\n    url += \"?\" + _.HTTPBuildQuery(data);\n    let img = document.createElement(\"img\");\n    img.src = url;\n    img.width = 1;\n    img.height = 1;\n\n    if (_.isFunction(callback)) {\n      callback(0);\n    }\n\n    img.onload = function () {\n      this.onload = null;\n    };\n\n    img.onerror = function () {\n      this.onerror = null;\n    };\n\n    img.onabort = function () {\n      this.onabort = null;\n    };\n  } else if (type === \"get\") {\n    url += \"?\" + _.HTTPBuildQuery(data);\n\n    _.ajax.get(url, callback);\n  } else if (type === \"post\") {\n    _.ajax.get(url, data, callback);\n  }\n};\n\n_.ajax = {\n  post: function (url, options, callback, timeout) {\n    var that = this;\n\n    that.callback = callback || function (params) {};\n\n    try {\n      var req = new XMLHttpRequest();\n      req.open(\"POST\", url, true);\n      req.setRequestHeader(\"Content-type\", \"application/json\");\n      req.withCredentials = true;\n\n      req.ontimeout = function () {\n        that.callback({\n          status: 0,\n          error: true,\n          message: \"request \" + url + \" time out\"\n        });\n      };\n\n      req.onreadystatechange = function () {\n        if (req.readyState === 4) {\n          if (req.status === 200) {\n            that.callback(_.JSONDecode(req.responseText));\n          } else {\n            var message = \"Bad HTTP status: \" + req.status + \" \" + req.statusText;\n            that.callback({\n              status: 0,\n              error: true,\n              message: message\n            });\n          }\n        }\n      };\n\n      req.timeout = timeout || 5000;\n      req.send(_.JSONEncode(options));\n    } catch (e) {}\n  },\n  get: function (url, callback) {\n    try {\n      var req = new XMLHttpRequest();\n      req.open(\"GET\", url, true);\n      req.withCredentials = true;\n\n      req.onreadystatechange = function () {\n        if (req.readyState === 4) {\n          if (req.status === 200) {\n            if (callback) {\n              callback(req.responseText);\n            }\n          } else {\n            if (callback) {\n              var message = \"Bad HTTP status: \" + req.status + \" \" + req.statusText;\n              callback({\n                status: 0,\n                error: true,\n                message: message\n              });\n            }\n          }\n        }\n      };\n\n      req.send(null);\n    } catch (e) {}\n  }\n}; // uuid\n\n_.UUID = function () {\n  var T = function () {\n    var d = 1 * new Date(),\n        i = 0;\n\n    while (d == 1 * new Date()) {\n      i++;\n    }\n\n    return d.toString(16) + i.toString(16);\n  };\n\n  var R = function () {\n    return Math.random().toString(16).replace(\".\", \"\");\n  };\n\n  var UA = function (n) {\n    var ua = navigator.userAgent,\n        i,\n        ch,\n        buffer = [],\n        ret = 0;\n\n    function xor(result, byte_array) {\n      var j,\n          tmp = 0;\n\n      for (j = 0; j < byte_array.length; j++) {\n        tmp |= buffer[j] << j * 8;\n      }\n\n      return result ^ tmp;\n    }\n\n    for (i = 0; i < ua.length; i++) {\n      ch = ua.charCodeAt(i);\n      buffer.unshift(ch & 0xff);\n\n      if (buffer.length >= 4) {\n        ret = xor(ret, buffer);\n        buffer = [];\n      }\n    }\n\n    if (buffer.length > 0) {\n      ret = xor(ret, buffer);\n    }\n\n    return ret.toString(16);\n  };\n\n  return function () {\n    // 有些浏览器取个屏幕宽度都异常...\n    var se = String(screen.height * screen.width);\n\n    if (se && /\\d{5,}/.test(se)) {\n      se = se.toString(16);\n    } else {\n      se = String(Math.random() * 31242).replace(\".\", \"\").slice(0, 8);\n    }\n\n    var val = T() + \"-\" + R() + \"-\" + UA() + \"-\" + se + \"-\" + T();\n\n    if (val) {\n      return val;\n    } else {\n      return (String(Math.random()) + String(Math.random()) + String(Math.random())).slice(2, 15);\n    }\n  };\n}(); // 存储方法封装 localStorage  cookie\n\n\n_.localStorage = {\n  error: function (msg) {\n    console.error(\"localStorage error: \" + msg);\n  },\n  get: function (name) {\n    try {\n      return window.localStorage.getItem(name);\n    } catch (err) {\n      _.localStorage.error(err);\n    }\n\n    return null;\n  },\n  parse: function (name) {\n    try {\n      return _.JSONDecode(_.localStorage.get(name)) || {};\n    } catch (err) {// noop\n    }\n\n    return null;\n  },\n  set: function (name, value) {\n    try {\n      window.localStorage.setItem(name, value);\n    } catch (err) {\n      _.localStorage.error(err);\n    }\n  },\n  remove: function (name) {\n    try {\n      window.localStorage.removeItem(name);\n    } catch (err) {\n      _.localStorage.error(err);\n    }\n  }\n};\n_.cookie = {\n  get: function (name) {\n    var nameEQ = name + \"=\";\n    var ca = document.cookie.split(\";\");\n\n    for (var i = 0; i < ca.length; i++) {\n      var c = ca[i];\n\n      while (c.charAt(0) == \" \") {\n        c = c.substring(1, c.length);\n      }\n\n      if (c.indexOf(nameEQ) === 0) {\n        return decodeURIComponent(c.substring(nameEQ.length, c.length));\n      }\n    }\n\n    return null;\n  },\n  parse: function (name) {\n    var cookie;\n\n    try {\n      cookie = _.JSONDecode(_.cookie.get(name)) || {};\n    } catch (err) {// noop\n    }\n\n    return cookie;\n  },\n  set_seconds: function (name, value, seconds, cross_subdomain, is_secure) {\n    var cdomain = \"\",\n        expires = \"\",\n        secure = \"\";\n\n    if (cross_subdomain) {\n      var matches = document.location.hostname.match(/[a-z0-9][a-z0-9\\-]+\\.[a-z\\.]{2,6}$/i),\n          domain = matches ? matches[0] : \"\";\n      cdomain = domain ? \"; domain=.\" + domain : \"\";\n    }\n\n    if (seconds) {\n      var date = new Date();\n      date.setTime(date.getTime() + seconds * 1000);\n      expires = \"; expires=\" + date.toGMTString();\n    }\n\n    if (is_secure) {\n      secure = \"; secure\";\n    }\n\n    document.cookie = name + \"=\" + encodeURIComponent(value) + expires + \"; path=/\" + cdomain + secure;\n  },\n  set: function (name, value, days, cross_subdomain, is_secure) {\n    var cdomain = \"\",\n        expires = \"\",\n        secure = \"\";\n\n    if (cross_subdomain) {\n      var matches = document.location.hostname.match(/[a-z0-9][a-z0-9\\-]+\\.[a-z\\.]{2,6}$/i),\n          domain = matches ? matches[0] : \"\";\n      cdomain = domain ? \"; domain=.\" + domain : \"\";\n    }\n\n    if (days) {\n      var date = new Date();\n      date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);\n      expires = \"; expires=\" + date.toGMTString();\n    }\n\n    if (is_secure) {\n      secure = \"; secure\";\n    }\n\n    var new_cookie_val = name + \"=\" + encodeURIComponent(value) + expires + \"; path=/\" + cdomain + secure;\n    document.cookie = new_cookie_val;\n    return new_cookie_val;\n  },\n  remove: function (name, cross_subdomain) {\n    _.cookie.set(name, \"\", -1, cross_subdomain);\n  }\n};\nconst windowConsole = win.console;\nconst console = {\n  /** @type {function(...[*])} */\n  log: function () {\n    if (CONFIG.DEBUG && !_.isUndefined(windowConsole) && windowConsole) {\n      try {\n        windowConsole.log.apply(windowConsole, arguments);\n      } catch (err) {\n        _.each(arguments, function (arg) {\n          windowConsole.log(arg);\n        });\n      }\n    }\n  },\n\n  /** @type {function(...[*])} */\n  error: function () {\n    if (CONFIG.DEBUG && !_.isUndefined(windowConsole) && windowConsole) {\n      var args = [\"DATracker error:\"].concat(_.toArray(arguments));\n\n      try {\n        windowConsole.error.apply(windowConsole, args);\n      } catch (err) {\n        _.each(args, function (arg) {\n          windowConsole.error(arg);\n        });\n      }\n    }\n  },\n\n  /** @type {function(...*)} */\n  critical: function () {\n    if (!_.isUndefined(windowConsole) && windowConsole) {\n      var args = [\"error:\"].concat(_.toArray(arguments));\n\n      try {\n        windowConsole.error.apply(windowConsole, args);\n      } catch (err) {\n        _.each(args, function (arg) {\n          windowConsole.error(arg);\n        });\n      }\n    }\n  }\n};\n/**\r\n    字符串加密\r\n    简单的加密方法\r\n  */\n\n_.compile = function (code) {\n  let c = String.fromCharCode(code.charCodeAt(0) + code.length);\n\n  for (let i = 1; i < code.length; i++) {\n    c += String.fromCharCode(code.charCodeAt(i) + code.charCodeAt(i - 1));\n  }\n\n  return c;\n};\n/**\r\n    字符串解谜\r\n    对应上面的字符串加密方法\r\n  */\n\n\n_.uncompile = function (code) {\n  let c = String.fromCharCode(code.charCodeAt(0) - code.length);\n\n  for (let i = 1; i < code.length; i++) {\n    c += String.fromCharCode(code.charCodeAt(i) - c.charCodeAt(i - 1));\n  }\n\n  return c;\n}; // UNDERSCORE\n// Embed part of the Underscore Library\n\n\n_.bind = function (func, context) {\n  var args, bound;\n\n  if (nativeBind && func.bind === nativeBind) {\n    return nativeBind.apply(func, slice.call(arguments, 1));\n  }\n\n  if (!_.isFunction(func)) {\n    throw new TypeError();\n  }\n\n  args = slice.call(arguments, 2);\n\n  bound = function () {\n    if (!(this instanceof bound)) {\n      return func.apply(context, args.concat(slice.call(arguments)));\n    }\n\n    var ctor = {};\n    ctor.prototype = func.prototype;\n    var self = new ctor();\n    ctor.prototype = null;\n    var result = func.apply(self, args.concat(slice.call(arguments)));\n\n    if (Object(result) === result) {\n      return result;\n    }\n\n    return self;\n  };\n\n  return bound;\n};\n\n_.bindInstanceMethods = function (obj) {\n  for (var func in obj) {\n    if (typeof obj[func] === \"function\") {\n      obj[func] = _.bind(obj[func], obj);\n    }\n  }\n};\n\n_.safewrap = function (f) {\n  return function () {\n    try {\n      return f.apply(this, arguments);\n    } catch (e) {\n      console.log(\"Implementation error. Please turn on debug and contact support@mixpanel.com.\");\n\n      if (CONFIG.DEBUG) {\n        console.log(e);\n      }\n    }\n  };\n};\n\n_.safewrap_class = function (klass, functions) {\n  for (var i = 0; i < functions.length; i++) {\n    klass.prototype[functions[i]] = _.safewrap(klass.prototype[functions[i]]);\n  }\n};\n\n_.safewrapInstanceMethods = function (obj) {\n  for (var func in obj) {\n    if (typeof obj[func] === \"function\") {\n      obj[func] = _.safewrap(obj[func]);\n    }\n  }\n};\n\n_.getById = function (id) {\n  return document.getElementById(id);\n};\n\n_.getPropsDom = function (parentNode, propsName) {\n  return parentNode.querySelectorAll(\"[\".concat(propsName, \"]\"));\n};\n\nclass USER_TRACK {\n  constructor(instance) {\n    this.instance = instance;\n    this['local_storage'] = this.instance['local_storage'];\n  }\n  /**\r\n   * 检测设置的属性是否为系统保留属性\r\n   * @param {String} prop \r\n   */\n\n\n  _is_reserved_property(prop) {\n    return PEOPLE_RESERVED_PROPERTY.indexOf('prop') > -1;\n  }\n  /**\r\n   * 上报用户属性数据\r\n   * @param {Object} properties \r\n   * @param {Function} callback \r\n   */\n\n\n  _send_request(properties, callback) {\n    if (!_.isFunction(callback)) {\n      callback = function () {};\n    }\n\n    properties = properties || {};\n    let data = {\n      dataType: SYSTEM_EVENT_TYPE,\n      // 客户端唯一凭证(设备凭证)\n      deviceId: this.instance.get_device_id(),\n      userId: this.instance.get_property('user_id'),\n      // 上报时间\n      time: new Date().getTime(),\n      // sdk类型 （js，小程序、安卓、IOS、server、pc）\n      sdkType: 'js',\n      // 属性事件id\n      eventId: PEOPLE_PROPERTY_ID,\n      // 用户首次访问时间\n      persistedTime: this.instance.get_property('persistedTime'),\n      // 页面打开场景, 默认 Browser\n      pageOpenScene: 'Browser',\n      // 自定义用户属性\n      attributes: properties\n    }; // 合并渠道推广信息\n    // data = _.extend({}, data, this.instance['channel'].get_channel_params());\n    // 上报数据对象字段截取\n\n    const truncateLength = this.instance._get_config('truncateLength');\n\n    let truncated_data = data;\n\n    if (_.isNumber(truncateLength) && truncateLength > 0) {\n      truncated_data = _.truncate(data, truncateLength);\n    }\n\n    console.log(JSON.stringify(truncated_data, null, \"  \"));\n\n    const callback_fn = response => {\n      callback(response, data);\n    };\n\n    let url = this.instance._get_config('track_url'); // 数据上报方式\n\n\n    const track_type = this.instance._get_config('track_type');\n\n    if (track_type === 'img') {\n      url += 'track.gif';\n    }\n\n    _.sendRequest(url, track_type, {\n      data: _.base64Encode(_.JSONEncode(truncated_data)),\n      token: this.instance._get_config('token')\n    }, callback_fn);\n  }\n  /**\r\n   * 设置用户属性\r\n   * @param {*} prop \r\n   * @param {*} to \r\n   * @param {*} callback \r\n   */\n\n\n  set(prop, to, callback) {\n    let set_props = {};\n\n    if (_.isObject(prop)) {\n      _.each(prop, (v, k) => {\n        // 不是系统保留属性\n        if (!this._is_reserved_property(k)) {\n          set_props[k] = v;\n        }\n      });\n\n      callback = to;\n    } else {\n      set_props[prop] = to;\n    }\n\n    return this._send_request(set_props, callback);\n  }\n\n}\n\nclass EVENT_TRACK {\n  constructor(instance) {\n    this.instance = instance;\n    this[\"local_storage\"] = this.instance[\"local_storage\"]; // 初始化时间(事件相关)\n\n    this[\"local_storage\"].register_once({\n      updatedTime: 0,\n      sessionStartTime: 0\n    }); // 将当前的referrer保存到本地缓存\n\n    this[\"local_storage\"].register({\n      sessionReferrer: document.referrer\n    });\n    let mark_page_url = document.URL; // 单页面触发PV事件时，设置 referrer\n\n    _.innerEvent.on(\"singlePage:change\", (eventName, urlParams) => {\n      this[\"local_storage\"].register({\n        sessionReferrer: mark_page_url\n      });\n      mark_page_url = document.URL;\n    });\n  }\n  /**\r\n   *\r\n   * 判断是否为其它渠道\r\n   */\n\n\n  _check_channel() {\n    const referrer = this.instance.get_property(\"sessionReferrer\");\n    let is_other_channel = false; // 若本地缓存的referrer 的host跟当前页不一样，那么可以确定是其它渠道进来的\n\n    if (_.getHost(referrer) !== window.location.host) {\n      is_other_channel = true;\n    }\n\n    return is_other_channel;\n  }\n  /**\r\n   * TODO\r\n   * 判断指定事件是否被禁止上报\r\n   * @param {String} event_name\r\n   * @returns {Boolean}\r\n   */\n\n\n  _event_is_disabled(event_name) {\n    return false;\n  }\n  /**\r\n   * 打开新会话\r\n   */\n\n\n  _start_new_session() {\n    this[\"local_storage\"].register({\n      sessionUuid: _.UUID(),\n      sessionStartTime: new Date().getTime()\n    });\n    this.track(\"sxfData_session_start\");\n  }\n  /**\r\n   * TODO\r\n   * 关闭当前会话\r\n   */\n\n\n  _close_cur_session() {\n    /*\r\n     为了便于绘制用户事件发生轨迹图，区分会话close和最后一次事件触发时间的顺序，会话关闭时间需要做些微调\r\n     1. 如果本地拿到了上次（非会话事件）事件的触发时间，time = this.instance.get_property('LASTEVENT').time + 1;\r\n     2. 如果未拿到，time = new Date().getTime() - 1;\r\n    */\n    let time = new Date().getTime() - 1;\n    const sessionStartTime = this.instance.get_property(\"sessionStartTime\");\n    const LASTEVENT = this.instance.get_property(\"LASTEVENT\");\n\n    if (LASTEVENT && LASTEVENT.time) {\n      time = LASTEVENT.time + 1;\n    }\n\n    const sessionTotalLength = time - sessionStartTime;\n\n    if (sessionTotalLength >= 0) {\n      this.track(\"sxfData_session_close\", {\n        sessionCloseTime: time,\n        sessionTotalLength: sessionTotalLength\n      });\n    }\n  }\n  /**\r\n   * 判断会话重新开启\r\n   * 判断条件：会话首次开始、指定的一段时间内用户无事件操作、其它渠道进来\r\n   */\n\n\n  _session(callback) {\n    const session_start_time = 1 * this.instance.get_property(\"sessionStartTime\") / 1000;\n    const updated_time = 1 * this.instance.get_property(\"updatedTime\") / 1000;\n    const now_date_time_ms = new Date().getTime();\n    const now_date_time_se = 1 * now_date_time_ms / 1000; // 其它渠道判断\n\n    const other_channel_Bool = this._check_channel(); //会话结束判断\n\n\n    if (session_start_time === 0 || now_date_time_se > updated_time + 60 * this.instance._get_config(\"session_interval_mins\") || other_channel_Bool) {\n      // 当会话首次开始时，不用发送会话关闭事件\n      if (session_start_time === 0) {\n        // 新打开一个会话\n        this._start_new_session();\n      } else {\n        this._close_cur_session();\n\n        this._start_new_session();\n      }\n    } // 更新本地的最后事件操作时间\n\n\n    this[\"local_storage\"].register({\n      updatedTime: now_date_time_ms\n    }); // 执行回调方法\n\n    if (_.isFunction(callback)) {\n      callback();\n    }\n  }\n  /**\r\n   * 用户注册\r\n   * @param {String} user_id\r\n   */\n\n\n  _signup(user_id) {\n    // 默认是空值,若有值则调用退出\n    const anonymous_id = this.instance.get_property(\"userId\");\n\n    if (anonymous_id !== user_id) {\n      if (anonymous_id) {\n        this.logout();\n      }\n\n      this.track(\"sxfData_u_signup\", {\n        anonymousId: anonymous_id,\n        newUserId: user_id\n      });\n    }\n  }\n  /**\r\n   * 设置一个指定事件的耗时监听器\r\n   * @param {String} event_name\r\n   */\n\n\n  time_event(event_name) {\n    if (_.isUndefined(event_name)) {\n      console.error(\"事件耗时监听器需要一个事件名称\");\n      return;\n    } // 被禁止的事件，无需监听\n\n\n    if (this._event_is_disabled(event_name)) {\n      return;\n    }\n\n    this[\"local_storage\"].set_event_timer(event_name, new Date().getTime());\n  }\n  /**\r\n   * 发送PV事件，在此之前检测session\r\n   * @param {Object} properties  pv属性\r\n   * @param {*} callback\r\n   */\n\n\n  track_pv(properties, callback) {\n    this._session(() => {\n      this.track(\"sxfData_pv\", _.extend({}, properties), callback);\n    });\n  }\n  /**\r\n   * 追踪事件（上报用户事件触发数据）\r\n   * @param {String} event_name 事件名称（必须）\r\n   * @param {Object} properties 事件属性\r\n   * @param {Function} callback 上报后的回调方法\r\n   * @param {String} event_type 自定义事件类型\r\n   * @returns {Object} track_data 上报的数据\r\n   */\n\n\n  track(event_name, properties, callback, event_type) {\n    if (_.isUndefined(event_name)) {\n      console.error(\"上报数据需要一个事件名称\");\n      return;\n    }\n\n    if (!_.isFunction(callback)) {\n      callback = function () {};\n    }\n\n    if (this._event_is_disabled(event_name)) {\n      callback(0);\n      return;\n    } // 重新在本地取数据读取到缓存\n\n\n    this[\"local_storage\"].load(); // 事件属性\n\n    properties = properties || {}; // 标记：传入的属性另存一份\n\n    let user_set_properties = _.JSONDecode(_.JSONEncode(properties)) || {};\n    let costTime; // 移除该事件的耗时监听器，获取设置监听器的时间戳，计算耗时\n\n    const start_listen_timestamp = this[\"local_storage\"].remove_event_timer(event_name);\n\n    if (!_.isUndefined(start_listen_timestamp)) {\n      costTime = new Date().getTime() - start_listen_timestamp;\n    } // 事件类型设置\n\n\n    let data_type = BUSSINESS_EVENT_TYPE; // 事件类型设置为传入了自定义事件类型\n\n    if (event_type) {\n      data_type = event_type;\n    } // 如果是内置事件,事件类型重新设置\n    else if (SYSTEM_EVENT_OBJECT[event_name]) {\n        data_type = SYSTEM_EVENT_OBJECT[event_name].data_type;\n      } // 事件触发时间\n\n\n    let time = new Date().getTime(); // 会话有时间差\n    // 触发的事件若是会话结束，触发时间要重新设置\n    // 若事件id为会话关闭，需要删除传入的自定义属性\n\n    if (event_name === \"sxfData_session_close\") {\n      time = properties.sessionCloseTime;\n      delete user_set_properties[\"sessionCloseTime\"];\n      delete user_set_properties[\"sessionTotalLength\"];\n    } // 设置通用的事件属性\n\n\n    user_set_properties = _.extend({}, this.instance.get_property(\"superProperties\"), user_set_properties); // 上报数据\n\n    let data = {\n      dataType: data_type,\n      userId: this.instance.get_property(\"userId\"),\n      // sdk类型 （js，小程序、安卓、IOS、server、pc）\n      sdkType: \"js\",\n      sdkVersion: CONFIG.LIB_VERSION,\n      // 事件名称\n      eventId: event_name,\n      // 事件触发时间\n      time: time,\n      // 用户首次访问时间\n      persistedTime: this.instance.get_property(\"persistedTime\"),\n      // 客户端唯一凭证(设备凭证)\n      deviceId: this.instance.get_device_id(),\n      // 页面打开场景, 默认 Browser\n      pageOpenScene: \"Browser\",\n      // 应用凭证\n      token: this.instance._get_config(\"token\"),\n      // 监听事件耗时\n      costTime: costTime,\n      // 当前关闭的会话时长\n      sessionTotalLength: properties.sessionTotalLength,\n      // 当前会话id\n      sessionUuid: this.instance.get_property(\"sessionUuid\"),\n      // 事件自定义属性\n      attributes: user_set_properties\n    }; // 合并客户端信息\n\n    data = _.extend({}, data, _.info.properties()); // 合并渠道推广信息\n    // data = _.extend({}, data, this.instance[\"channel\"].get_channel_params());\n    //只有已访问页面后，sessionReferrer 重置\n    //如果不是内置事件，那么 sessionReferrer 重置\n    //如果是'da_activate'，那么 sessionReferrer 重置\n    //解决referrer 当是外链时，此时触发自定义事件，引起重启一个session问题。\n\n    if (data_type === BUSSINESS_EVENT_TYPE) {\n      // 其它渠道\n      if (this._check_channel()) {\n        this[\"local_storage\"].register({\n          sessionReferrer: document.URL\n        });\n      }\n    }\n\n    if (!this.instance._get_config(\"SPA\").is) {\n      if ([\"sxfData_activate\", \"sxfData_session_close\"].indexOf(event_name) > 0) {\n        this[\"local_storage\"].register({\n          sessionReferrer: document.URL\n        });\n      }\n    } // 当启动单页面后，切换页面，refer为空，此时做处理\n\n\n    if (this.instance._get_config(\"SPA\").is) {\n      const sessionReferrer = this.instance.get_property(\"sessionReferrer\");\n\n      if (sessionReferrer !== data[\"referrer\"]) {\n        data[\"referrer\"] = sessionReferrer;\n        data[\"referringDomain\"] = _.info.domain(sessionReferrer);\n      }\n    } // 上报数据对象字段截取\n\n\n    const truncateLength = this.instance._get_config(\"truncateLength\");\n\n    let truncated_data = data;\n\n    if (_.isNumber(truncateLength) && truncateLength > 0) {\n      truncated_data = _.truncate(data, truncateLength);\n    }\n\n    console.log(JSON.stringify(truncated_data, null, \"  \"));\n\n    const callback_fn = response => {\n      callback(response, data);\n    };\n\n    let url = this.instance._get_config(\"track_url\");\n\n    const track_type = this.instance._get_config(\"track_type\");\n\n    if (track_type === \"img\") {\n      url += \"track.gif\";\n    }\n\n    if (!this.instance._get_config(\"isBpoint\") || user_set_properties && user_set_properties.sxfDataConfig && !user_set_properties.sxfDataConfig.isBpoint) {\n      _.sendRequest(url, track_type, {\n        data: _.base64Encode(_.JSONEncode(truncated_data)),\n        token: this.instance._get_config(\"token\")\n      }, callback_fn);\n    } else {\n      try {\n        this.instance[\"bpoint\"].push(truncated_data);\n      } catch (error) {\n        _.sendRequest(url, track_type, {\n          data: _.base64Encode(_.JSONEncode(truncated_data)),\n          token: this.instance._get_config(\"token\")\n        }, callback_fn);\n      }\n    } // 当触发的事件不是这些事件(sxfData_session_start,sxfData_session_close,sxfData_activate)时，触发检测 session 方法\n\n\n    if ([\"sxfData_session_start\", \"sxfData_session_close\", \"sxfData_activate\"].indexOf(event_name) === -1) {\n      this._session();\n    } // 保存最后一次用户触发事件（除了会话事件以外）的事件id以及时间，通过这个时间确定会话关闭时的时间\n\n\n    if ([\"sxfData_session_start\", \"sxfData_session_close\"].indexOf(event_name) === -1) {\n      this[\"local_storage\"].register({\n        LASTEVENT: {\n          eventId: event_name,\n          time: time\n        }\n      });\n    }\n  }\n  /**\r\n   * 用户登录和注册时调用\r\n   * @param {String} user_id\r\n   */\n\n\n  login(user_id) {\n    this._signup(user_id);\n\n    this[\"local_storage\"].register({\n      userId: user_id\n    });\n    this.track(\"sxfData_u_login\");\n  } // 清除本地用户信息，退出用户（选则调用）\n\n\n  logout() {\n    this[\"local_storage\"].unregister(\"userId\");\n    this.track(\"sxfData_u_logout\");\n  }\n\n}\n\nclass LOCAL_STORAGE {\n  /**\r\n   * \r\n   * @param {Object} config\r\n   */\n  constructor(config) {\n    const local_storage = config['local_storage'];\n\n    if (_.isObject(local_storage)) {\n      this['name'] = local_storage['name'] || 'sxfData_' + config['token'] + '_sdk';\n      let storage_type = local_storage['type'] || 'cookie'; // 判断是否支持 localStorage\n\n      const localStorage_supported = () => {\n        let supported = true;\n\n        try {\n          let key = '__sxfDatassupport__',\n              val = 'sxfData_web_data_sdk';\n\n          _.localStorage.set(key, val);\n\n          if (_.localStorage.get(key) !== val) {\n            supported = false;\n          }\n\n          _.localStorage.remove(key);\n        } catch (error) {\n          supported = false;\n        }\n\n        if (!supported) {\n          console.error('localStorage 不支持，自动退回到cookie存储方式');\n        }\n\n        return supported;\n      };\n\n      if (storage_type === 'localStorage' && localStorage_supported()) {\n        this['storage'] = _.localStorage;\n      } else {\n        this['storage'] = _.cookie;\n      }\n\n      this.load();\n      this.update_config(local_storage); // TODO: upgrade\n\n      this.upgrade();\n      this.save();\n    } else {\n      console.error('local_storage配置设置错误');\n    }\n  } // 加载本地存储信息\n\n\n  load() {\n    const localData = this['storage'].parse(this['name']);\n\n    if (localData) {\n      this['props'] = _.extend({}, localData);\n    }\n  } // 更新配置信息\n\n\n  update_config(localStorageConfig) {\n    // 到期时间(cookie存储设置有效)\n    this.default_expiry = this.expire_days = localStorageConfig['cookie_expiration'];\n    this.set_disabled(localStorageConfig['disable']);\n    this.set_cross_subdomain(localStorageConfig['cross_subdomain_cookie']);\n    this.set_secure(localStorageConfig['secure_cookie']);\n  } // 设置关闭本地保存操作，设置为关闭后，本地数据移除\n\n\n  set_disabled(disabled) {\n    this.disabled = disabled;\n\n    if (this.disabled) {\n      this.remove();\n    }\n  } // 移除本地数据\n\n\n  remove() {\n    // cookie存储时，移除二级域以及子域下的cookie,此时参数有两个\n    this.storage.remove(this.name, false);\n    this.storage.remove(this.name, true);\n  } // 清除存储的数据\n\n\n  clear() {\n    this.remove();\n    this['props'] = {};\n  }\n  /**\r\n   * 跨子域设置,cookie存储方式下有效\r\n   * @param {Boolean} cross_subdomain \r\n   */\n\n\n  set_cross_subdomain(cross_subdomain) {\n    if (cross_subdomain !== this.cross_subdomain) {\n      this.cross_subdomain = cross_subdomain;\n      this.remove();\n      this.save();\n    }\n  }\n  /**\r\n   * cookie存储方式下有效\r\n   * cookie存储时，采用安全的方式存储数据，调用该方法后，重新保存数据\r\n   * 当secure属性设置为true时，cookie只有在https协议下才能上传到服务器，\r\n   * 而在http协议下是没法上传的，所以也不会被窃听\r\n   * @param {Boolean} secure \r\n   */\n\n\n  set_secure(secure) {\n    if (secure !== this.secure) {\n      this.secure = secure ? true : false;\n      this.remove();\n      this.save();\n    }\n  } // sdk升级，旧的sdk存储数据移到新的sdk存储数据中，然后删除旧的存储数据（暂不实现）\n  // 存储方式改变，改为cookie切换到 localStorage\n\n\n  upgrade(config) {\n    let old_cookie;\n\n    if (this.storage === _.localStorage) {\n      old_cookie = _.cookie.parse(this.name);\n\n      _.cookie.remove(this.name);\n\n      _.cookie.remove(this.name, true);\n\n      if (old_cookie) {\n        this.register_once(old_cookie);\n      }\n    }\n  } // 数据保存到本地\n\n\n  save() {\n    // disabled配置为true, 数据不保存到本地\n    if (this.disabled) {\n      return;\n    }\n\n    this.storage.set(this['name'], _.JSONEncode(this['props']), this.expire_days, this.cross_subdomain, this.secure);\n  }\n  /**\r\n   * 缓存指定的数据，同时将该数据保存到本地\r\n   * @param {Object} props \r\n   * @param {Number} days\r\n   * @returns {Boolean} 返回true表示成功\r\n   */\n\n\n  register(props, days) {\n    if (_.isObject(props)) {\n      this.expire_days = typeof days === 'undefined' ? this.default_expiry : days;\n\n      _.extend(this['props'], props);\n\n      this.save();\n      return true;\n    }\n\n    return false;\n  }\n  /**\r\n   * 只缓存一次指定的数据，下次设置该数据时不会覆盖前一次数据\r\n   * 若想更新已设置的属性值，那么default_value参数值要等于本地缓存数据中需重置的属性的值(默认值)\r\n   * this['props'][prop] === default_value   prop为需更新的属性\r\n   * @param {Object} props\r\n   * @param {*} default_value\r\n   * @param {Number} days\r\n   * @returns {Boolean} 返回true表示成功\r\n   */\n\n\n  register_once(props, default_value, days) {\n    if (_.isObject(props)) {\n      if (typeof default_value === 'undefined') {\n        default_value = 'None';\n      }\n\n      this.expire_days = typeof days === 'undefined' ? this.default_expiry : days;\n\n      _.each(props, function (val, prop) {\n        if (!this['props'][prop] || this['props'][prop] === default_value) {\n          this['props'][prop] = val;\n        }\n      }, this);\n\n      this.save();\n      return true;\n    }\n\n    return false;\n  }\n  /**\r\n   * 移除指定的缓存数据，同时也清除本地的对应数据\r\n   * @param {string} prop\r\n   */\n\n\n  unregister(prop) {\n    if (prop in this['props']) {\n      delete this['props'][prop];\n      this.save();\n    }\n  }\n  /**\r\n   * 设置一个事件计时器，记录用户触发指定事件需要的时间，同时保存到本地\r\n   * @param {String} event_name 该计时器的名称\r\n   * @param {Date} timestamp 该计时器开始时间戳\r\n   */\n\n\n  set_event_timer(event_name, timestamp) {\n    const timers = this['props']['costTime'] || {};\n    timers[event_name] = timestamp;\n    this['props']['costTime'] = timers;\n    this.save();\n  }\n  /**\r\n   * 移除指定计时器，同时将本地存储的该计时器信息清除\r\n   * @param {String} event_name\r\n   * @returns {Date} 返回移除该计时器的时间戳\r\n   */\n\n\n  remove_event_timer(event_name) {\n    const timers = this['props']['costTime'] || {};\n    const timestamp = timers[event_name];\n\n    if (!_.isUndefined(timestamp)) {\n      delete this['props']['costTime'][event_name];\n      this.save();\n    }\n\n    return timestamp;\n  }\n\n}\n/**\r\n * 单页面模块\r\n */\n\n\nfunction on(obj, event, callFn) {\n  if (obj[event]) {\n    const fn = obj[event];\n\n    obj[event] = function () {\n      const args = Array.prototype.slice.call(arguments);\n      callFn.apply(this, args);\n      fn.apply(this, args);\n    };\n  } else {\n    obj[event] = function () {\n      const args = Array.prototype.slice.call(arguments);\n      callFn.apply(this, args);\n    };\n  }\n}\n\nfunction getPath() {\n  return location.pathname + location.search;\n}\n\nconst SPA = {\n  config: {\n    mode: \"hash\",\n    track_replace_state: false,\n    callback_fn: () => {}\n  },\n\n  init(config) {\n    this.config = _.extend(this.config, config || {});\n    this.path = getPath();\n    this.url = document.URL;\n    this.event();\n  },\n\n  event() {\n    if (this.config.mode === \"history\") {\n      if (!history.pushState || !window.addEventListener) return;\n      on(history, \"pushState\", this.pushStateOverride.bind(this));\n      on(history, \"replaceState\", this.replaceStateOverride.bind(this));\n      window.addEventListener(\"popstate\", this.handlePopState.bind(this));\n    } else if (this.config.mode === \"hash\") {\n      _.register_hash_event(this.handleHashState.bind(this));\n    }\n  },\n\n  pushStateOverride() {\n    this.handleUrlChange(true);\n  },\n\n  replaceStateOverride() {\n    this.handleUrlChange(false);\n  },\n\n  handlePopState() {\n    this.handleUrlChange(true);\n  },\n\n  handleHashState() {\n    this.handleUrlChange(true);\n  },\n\n  handleUrlChange(historyDidUpdate) {\n    setTimeout(() => {\n      if (this.config.mode === \"hash\") {\n        if (_.isFunction(this.config.callback_fn)) {\n          this.config.callback_fn.call();\n\n          _.innerEvent.trigger(\"singlePage:change\", {\n            oldUrl: this.url,\n            nowUrl: document.URL\n          });\n\n          this.url = document.URL;\n        }\n      } else if (this.config.mode === \"history\") {\n        const oldPath = this.path;\n        const newPath = getPath();\n\n        if (oldPath != newPath && this.shouldTrackUrlChange(newPath, oldPath)) {\n          this.path = newPath;\n\n          if (historyDidUpdate || this.config.track_replace_state) {\n            if (typeof this.config.callback_fn === \"function\") {\n              this.config.callback_fn.call();\n\n              _.innerEvent.trigger(\"singlePage:change\", {\n                oldUrl: this.url,\n                nowUrl: document.URL\n              });\n\n              this.url = document.URL;\n            }\n          }\n        }\n      }\n    }, 0);\n  },\n\n  shouldTrackUrlChange(newPath, oldPath) {\n    return !!(newPath && oldPath);\n  }\n\n};\n\nclass BPOINT {\n  constructor(instance) {\n    this.instance = instance;\n    this._infoStack = []; //信息存储栈 收集的信息将暂存到这里 等待打包移动到待发送队列\n\n    this._waitSendQueue = []; //待发送队列，存储多个信息存储栈帧 等待被发送给后台\n\n    this._queueSending = false; //是否在队列递归发送栈帧\n\n    this._scanStackIntervalId = null; //stack 扫描定时器的id\n\n    this._scanWaitSendQqueueIntervalId = null; //WaitSendQqueue 扫描定时器的id\n\n    this._loadFN = []; //用于存储调用者需要在插件load时的执行的fn\n  }\n  /**\n   * 上一个页面的历史数据提交\n   * @private\n   */\n\n\n  _oldDataCheck() {\n    var oldData = _.localStorage.get(\"_bp_wqueue\");\n\n    if (oldData != null && oldData != \"\") {\n      try {\n        oldData = eval(\"(\" + oldData + \")\");\n\n        if (_.isArray(oldData) && oldData.length > 0) {\n          var sendData = {};\n          sendData = _.localStorage.set(\"_bp_infoConf\");\n          sendData = eval(\"(\" + sendData + \")\");\n\n          for (; oldData.length > 0;) {\n            sendData = oldData.pop(); //数据发送\n            //发送栈帧+环境配置信息\n\n            this._sendByImg(sendData);\n          }\n        }\n      } catch (e) {}\n\n      _.localStorage.remove(\"_bp_wqueue\");\n    }\n  }\n  /**\n   * 扫描信息栈中是否有数据 有数据 则将数据栈移入队列\n   * @param t\n   * @private\n   */\n\n\n  _scanStack(t) {\n    if (t != null && t >= 1) {\n      if (this._scanStackIntervalId != null) {\n        //如果已经存在定时器 需要先删除此定时，再创建新的定时器，防止出现重复定时器创建，最终导致内存泄露\n        clearInterval(this._scanStackIntervalId);\n      }\n\n      this._scanStackIntervalId = setInterval(() => {\n        this.stack2queue();\n      }, t * 1000);\n    } else {\n      console.log(\"埋点内置对象丢失,栈扫描器创建失败\", 1);\n      throw new ReferenceError(\"埋点内置对象丢失,栈扫描器创建失败\");\n    }\n  }\n\n  _scanWaitSendQqueue(t) {\n    if (t != null && t >= 1) {\n      if (this._scanWaitSendQqueueIntervalId != null) {\n        //如果已经存在定时器 需要先删除此定时，再创建新的定时器，防止出现重复定时器创建，最终导致内存泄露\n        clearInterval(this._scanWaitSendQqueueIntervalId);\n      }\n\n      this._scanWaitSendQqueueIntervalId = setInterval(() => {\n        console.log(\"开启等待发送--scanWaitSendQqueue\");\n        this.send();\n      }, t * 1000);\n    } else {\n      console.log(\"埋点内置对象丢失,队列扫描器创建失败\", 1);\n      throw new ReferenceError(\"埋点内置对象丢失,队列扫描器创建失败\");\n    }\n  }\n  /**\n   * 发送队列里最老的栈帧\n   */\n\n\n  sendOldestStack() {\n    var stack = this._waitSendQueue.shift();\n\n    if (_.localStorage) {\n      _.localStorage.set(\"_bp_wqueue\", JSON.stringify(this._waitSendQueue));\n    }\n\n    console.log(\"send stack(queue shift):\");\n    var sendData = {};\n    sendData = stack; //数据发送\n    //发送栈帧+环境配置信息\n\n    this._sendByImg(sendData);\n  }\n\n  _sendByImg(truncated_data) {\n    console.log(\"truncated_data\", truncated_data);\n\n    let url = this.instance._get_config(\"track_url\");\n\n    const track_type = this.instance._get_config(\"track_type\");\n\n    if (track_type === \"img\") {\n      url += \"track.gif\";\n    }\n\n    _.sendRequest(url, track_type, {\n      data: _.base64Encode(_.JSONEncode(truncated_data)),\n      token: this.instance._get_config(\"token\")\n    }, () => {});\n  }\n  /**\n   * 设置存在埋点信息的栈的大小\n   * 调用此方法，如果栈的数据量>stackSize，则触发栈帧入待发送队列\n   * @param stackSize 栈的大小 大于0的整数 如果是小数或者字符串，将先使用parseInt处理\n   */\n\n\n  setStackSize(stackSize) {\n    stackSize = parseInt(stackSize);\n\n    if (stackSize < 1) {\n      return;\n    }\n\n    this._option.stackSize = stackSize;\n\n    if (this._infoStack.length >= stackSize) {\n      // 如果已经满了 则送入待发送队列\n      this.stack2queue();\n    }\n  }\n  /**\n   * 栈帧入队列  等待被发送\n   */\n\n\n  stack2queue() {\n    console.log(\"开始扫描--scanStack\");\n    var is = this._infoStack; // if (window._sxfmt && window._sxfmt.length > 0) {\n    //   console.log(\"_sxfmt.length=\" + _sxfmt.length);\n    //   console.log(_sxfmt);\n    //   is = is.concat(_sxfmt);\n    //   window._sxfmt = [];\n    // }\n\n    console.log(\"infoStack length=\" + is.length);\n\n    if (is.length > 0) {\n      this._queueSave(is);\n\n      this._infoStack = [];\n    } else {\n      console.log(\"关闭扫描--_scanStackInterval\");\n      clearInterval(this._scanStackIntervalId);\n    }\n  }\n\n  _queueSave(is) {\n    this._waitSendQueue.push(is);\n\n    this._scanWaitSendQqueue(CONFIG.queueTime);\n\n    if (_.localStorage) {\n      _.localStorage.set(\"_bp_wqueue\", JSON.stringify(this._waitSendQueue));\n    }\n  }\n\n  _stackSave(infoObj) {\n    this._infoStack.push(infoObj); //检查信息栈是否已经满了\n\n\n    if (this._infoStack.length >= CONFIG.stackSize) {\n      // 如果已经满了 则送入待发送队列\n      this.stack2queue();\n    }\n  }\n\n  send() {\n    if (this._waitSendQueue.length == 0 || this._queueSending) {\n      return;\n    }\n\n    this._send();\n  }\n  /**\n   * 将队列的栈帧都间隔递归发送出去\n   */\n\n\n  _send() {\n    console.log(\"start send\");\n    console.log(\"waitSendQueue length=\" + this._waitSendQueue.length);\n\n    if (this._waitSendQueue.length == 0) {\n      console.log(\"关闭等待发送--_scanWaitSendQqueueInterval\");\n      clearInterval(this._scanWaitSendQqueueIntervalId);\n      this._queueSending = false;\n      return;\n    }\n\n    this._queueSending = true;\n    setTimeout(() => {\n      this.sendOldestStack();\n\n      this._send();\n    }, 500);\n  }\n  /**\n   * 收集的信息入栈\n   * @param infoObj\n   *\n   *  {\n   *      oc : //业务编码 opeCode\n   *      ac ：//行为编码 actionCode\n   *      v ：//行为结果 value 例如 输入框产生的值\n   *      ed:  //扩展信息 json\n   *  }\n   *\n   */\n\n\n  push(infoObj) {\n    if (infoObj) {\n      infoObj.dateTime = new Date().getTime();\n      console.log(infoObj);\n\n      this._scanStack(CONFIG.stackTime);\n\n      this._stackSave(infoObj);\n    }\n  }\n\n}\n\nclass INPUTLISTEN {\n  constructor(instance) {\n    this.instance = instance;\n  }\n\n  _addDomEventHandlers() {\n    try {\n      var rcidom = _.getPropsDom(document, \"data-sxf-props\");\n\n      rcidom.forEach(domItem => {\n        const eventItem = JSON.parse(domItem.getAttribute(\"data-sxf-props\"));\n        const eventType = eventItem.type;\n        const eventList = eventItem.eventList;\n        let data = {};\n        eventList.forEach(eventItem => {\n          _.register_event(domItem, eventItem.type, e => {\n            if (eventType === \"input\") {\n              data = {\n                input_value: e.target.value\n              };\n            }\n\n            this.instance[\"event\"].track(\"sxfData_\".concat(eventType, \"_\").concat(eventItem.type), data);\n          }, false, true);\n        });\n      });\n    } catch (error) {\n      console.error(\"自动添加监听事件失败,请校验语法是否有误！\");\n    }\n  }\n\n  bind(dom, kve) {\n    if (dom && kve) {\n      for (var k in kve) {\n        dom.addEventListener(k, kve[k]);\n      }\n\n      return dom;\n    }\n  }\n\n} // 用户属性追踪\n// 用户事件追踪\n// 本地存储\n// 单页面\n// 渠道跟踪\n// import CHANNEL from \"./channel\";\n// 断点发送\n// 远程拉取js文件（插件，具体内容请查看该文件）\n// import LOAD_CONTROL_JS from \"./load_control_js\";\n// 全面点\n// import { autotrack } from './autotrack';\n\n\nclass SxfDataLib {\n  /**\r\n   *\r\n   * @param {String} token 上报数据凭证\r\n   * @param {Object} config sdk客户端配置\r\n   */\n  constructor() {}\n\n  init(token, config) {\n    if (this[\"__loaded\"]) {\n      return;\n    }\n\n    this[\"__loaded\"] = true;\n    this._ = _;\n    this[\"config\"] = {};\n\n    this._set_config(_.extend({}, DEFAULT_CONFIG, CONFIG, config, {\n      token: token\n    }));\n\n    this[\"local_storage\"] = new LOCAL_STORAGE(this[\"config\"]); // 运行钩子函数\n\n    this._loaded(); // 实例化拉取远程库对象（按需加载）\n    // this[\"load_control_js\"] = new LOAD_CONTROL_JS(this);\n    // 实例化事件对象\n\n\n    this[\"event\"] = new EVENT_TRACK(this); // 实例化用户对象\n\n    this[\"user\"] = new USER_TRACK(this); // 实例化渠道跟踪对象\n    // this[\"channel\"] = new CHANNEL(this);\n\n    this[\"inputlisten\"] = new INPUTLISTEN(this); // 断点发送对象\n    // 设置设备凭证\n\n    this._set_device_id(); // 开启是否断点发送\n\n\n    if (this._get_config(\"isBpoint\")) {\n      this[\"bpoint\"] = new BPOINT(this);\n\n      this[\"bpoint\"]._oldDataCheck();\n\n      this[\"bpoint\"]._scanStack(CONFIG.stackTime);\n    } // 上报广告点击事件\n    // if (this[\"channel\"].check_ad_click()) {\n    //   this._ad_click();\n    // }\n\n\n    this._track_pv(); // this._autotrack();\n    // persistedTime 首次访问应用时间\n\n\n    this[\"local_storage\"].register_once({\n      persistedTime: new Date().getTime()\n    }, \"\"); // 单页面\n\n    if (this._get_config(\"SPA\").is) {\n      this._SPA();\n    }\n  } // 广告点击事件\n\n\n  _ad_click() {\n    this.track_event(\"sxfData_ad_click\");\n  } // 内部使用的PV方法\n\n\n  _track_pv(properties, callback) {\n    // 配置为自动触发PV事件\n    if (this._get_config(\"pageview\")) {\n      this[\"event\"].track_pv(properties, callback);\n    } else {\n      // 若没有自动触发事件，还需检测session (说明：当触发PV 时，实际已经检测了session)\n      this[\"event\"]._session();\n    }\n  } // 单页面应用（影响PV）\n\n\n  _SPA() {\n    SPA.init({\n      mode: this._get_config(\"SPA\").mode,\n      callback_fn: () => {\n        this._track_pv();\n      }\n    });\n  }\n  /**\r\n   * 设置配置\r\n   * @param {Object} config\r\n   */\n\n\n  _set_config(config) {\n    if (_.isObject(config)) {\n      this[\"config\"] = _.extend(this[\"config\"], config);\n      CONFIG.DEBUG = CONFIG.DEBUG || this._get_config(\"debug\");\n      CONFIG.isBpoint = CONFIG.isBpoint || this._get_config(\"isBpoint\");\n    }\n  }\n  /**\r\n   * 获取某个配置\r\n   * @param {String} prop_name\r\n   * @returns {*}\r\n   */\n\n\n  _get_config(prop_name) {\n    return this[\"config\"][prop_name];\n  } // sdk初始化之前触发的钩子函数，该方法必须在初始化子模块前以及上报数据前使用\n\n\n  _loaded() {\n    try {\n      this._get_config(\"loaded\")(this);\n    } catch (error) {\n      console.error(error);\n    }\n  }\n  /**\r\n   * 设置本地设备凭证\r\n   * 若是首次访问（本地无设备凭证），上报用户首次访问网站事件\r\n   */\n\n\n  _set_device_id() {\n    let track_data = {};\n\n    if (!this.get_device_id()) {\n      this[\"local_storage\"].register_once({\n        deviceId: _.UUID()\n      }, \"\");\n      track_data = this.track_event(\"sxfData_activate\");\n    }\n\n    return track_data;\n  } // 获取唯一凭证（设备标记）\n\n\n  get_device_id() {\n    return this.get_property(\"deviceId\");\n  } // 获取指定本地存储属性（缓存和本地）\n\n\n  get_property(prop_name) {\n    return this[\"local_storage\"][\"props\"][prop_name];\n  }\n  /**\r\n   * 设置一个指定事件的耗时监听器\r\n   * @param {String} event_name\r\n   */\n  // 监听事件\n\n\n  _addlisten(id) {\n    this[\"inputlisten\"]._addDomEventHandlers(id);\n  }\n\n  time_event(event_name) {\n    this[\"event\"].time_event(event_name);\n  }\n  /**\r\n   * 发送PV事件，在此之前检测session\r\n   * @param {Object} properties  pv属性\r\n   * @param {*} callback\r\n   */\n\n\n  track_pv(properties, callback) {\n    this[\"event\"].track_pv(properties, callback);\n  }\n  /**\r\n   * 追踪事件（上报用户事件触发数据）\r\n   * @param {String} event_name 事件名称（必须）\r\n   * @param {Object} properties 事件属性\r\n   * @param {Function} callback 上报后的回调方法\r\n   * @param {String} event_type 自定义事件类型\r\n   * @returns {Object} track_data 上报的数据\r\n   */\n\n\n  track_event(event_name, properties, callback, event_type) {\n    this[\"event\"].track(event_name, properties, callback, event_type);\n  }\n  /**\r\n   * 设置事件自定义通用属性\r\n   * 成功设置事件通用属性后，再通过 track_event: 追踪事件时，事件通用属性会被添加进每个事件中。\r\n   * 重复调用 register_event_super_properties: 会覆盖之前已设置的通用属性。\r\n   */\n\n\n  register_event_super_properties(prop, to) {\n    let set_props = {};\n    let super_properties = this.get_property(\"superProperties\");\n\n    if (_.isObject(prop)) {\n      _.each(prop, (v, k) => {\n        set_props[k] = v;\n      });\n    } else {\n      set_props[prop] = to;\n    } // 注意合并顺序\n\n\n    super_properties = _.extend({}, super_properties, set_props);\n    this[\"local_storage\"].register({\n      superProperties: super_properties\n    });\n  }\n  /**\r\n   * 设置事件自定义通用属性\r\n   * 成功设置事件通用属性后，再通过 track_event: 追踪事件时，事件通用属性会被添加进每个事件中。\r\n   * 不覆盖之前已经设定的通用属性。\r\n   */\n\n\n  register_event_super_properties_once(prop, to) {\n    let set_props = {};\n    let super_properties = this.get_property(\"superProperties\");\n\n    if (_.isObject(prop)) {\n      _.each(prop, (v, k) => {\n        set_props[k] = v;\n      });\n    } else {\n      set_props[prop] = to;\n    } // 注意合并顺序\n\n\n    super_properties = _.extend({}, set_props, super_properties);\n    this[\"local_storage\"].register({\n      superProperties: super_properties\n    });\n  }\n  /**\r\n   * 删除指定通用事件属性\r\n   * @param {String} prop_name\r\n   */\n\n\n  unregister_event_super_properties(prop_name) {\n    if (_.isString(prop_name)) {\n      let super_properties = this.get_property(\"superProperties\");\n\n      if (_.isObject(super_properties)) {\n        delete super_properties[prop_name];\n        this[\"local_storage\"].register({\n          superProperties: super_properties\n        });\n      }\n    }\n  }\n  /**\r\n   * 清除本地已设置的通用事件属性\r\n   */\n\n\n  clear_event_super_properties() {\n    this[\"local_storage\"].register({\n      superProperties: {}\n    });\n  }\n  /**\r\n   * 查看当前已设置的通用事件属性\r\n   */\n\n\n  current_event_super_properties() {\n    return this.get_property(\"superProperties\");\n  }\n  /**\r\n   * 用户登录和注册时调用\r\n   * @param {String} user_id\r\n   */\n\n\n  login(user_id) {\n    this[\"event\"].login(user_id);\n  } // 清除本地用户信息，退出用户（选则调用）,建议平台网站不必调用（无需匿名用户的平台）\n\n\n  logout() {\n    this[\"event\"].logout();\n  } //   _autotrack(){\n  //     autotrack.init(this);\n  //   }\n\n\n}\n\nlet sxfData = new SxfDataLib();\nexport default sxfData;","map":null,"metadata":{},"sourceType":"module"}